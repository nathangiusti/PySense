<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>PySense.PySense API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PySense.PySense</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import yaml

from PySense import PySenseDashboard
from PySense import PySenseElasticube
from PySense import PySenseException
from PySense import PySenseGroup
from PySense import PySenseFolder
from PySense import PySensePlugin
from PySense import PySenseRestConnector
from PySense import PySenseUser
from PySense import PySenseUtils


def authenticate_by_file(config_file):
    &#34;&#34;&#34;
    Creates a new PySense client with the credentials in the given config file.  

    :param config_file: Yaml file with entries for host, username, and password  
    
    :return: A new PySense client for the given credentials  
    &#34;&#34;&#34;
    
    with open(config_file, &#39;r&#39;) as yml_file:
        cfg = yaml.safe_load(yml_file)
        debug = cfg[&#39;debug&#39;] if &#39;debug&#39; in cfg else False
        return PySense(cfg[&#39;host&#39;], cfg[&#39;username&#39;], cfg[&#39;password&#39;], debug=debug)


class PySense:

    def __init__(self, host, username, password, *, debug=False):
        self.connector = PySenseRestConnector.RestConnector(host, username, password, debug)
        self._roles = self.connector.rest_call(&#39;get&#39;, &#39;api/roles&#39;)
        
    def set_debug(self, debug):
        &#34;&#34;&#34;
        Enable or disable logging of REST api calls to std out. Use for debugging. Debug is false by default.    
          
        :param debug:  True or False to enable or disable debug. 
        &#34;&#34;&#34;
        self.connector.debug = debug

    ############################################
    # Dashboards                               #
    ############################################

    def get_dashboards(self, *, parent_folder=None, name=None, data_source_title=None,
                       data_source_address=None, fields=None, sort=None, expand=None):
        &#34;&#34;&#34;
        Get all dashboards   
          
        Optional:  
        :param parent_folder: Parent folder to filter by  
        :param name: Name to filter by  
        :param data_source_title: Data source name to filter by  
        :param data_source_address: Data source address to filter by  
        :param fields: Whitelist of fields to return for each document.  
           Can also exclude by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param expand: List of fields that should be expanded  
          
        :return: All found dashboards  
        &#34;&#34;&#34;
        
        folder_id = None
        if parent_folder:
            folder_id = parent_folder.get_id()
            
        query_params = {
            &#39;parentFolder&#39;: folder_id,
            &#39;name&#39;: name,
            &#39;datasourceTitle&#39;: data_source_title,
            &#39;datasourceAddress&#39;: data_source_address,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;expand&#39;: expand
        }
        json_arr = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards&#39;, query_params=query_params)
        
        ret_arr = []
        for dash in json_arr:
            ret_arr.append(PySenseDashboard.Dashboard(self, dash))
        return ret_arr

    def get_dashboard_by_id(self, dashboard_id, *, fields=None, expand=None):
        &#34;&#34;&#34;  
        Returns a specific dashboard object by ID.  
  
        :param dashboard_id: The ID of the dashboard to get  
          
        Optional:  
        :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
            by prefixing field names with -  
        :param expand: List of fields that should be expanded (substitures their IDs with actual objects). May be nested
            using the resource.subResource format  
              
        :return: Dashboard with id given  
        &#34;&#34;&#34;
        
        query_params = {
            &#39;fields&#39;: fields,
            &#39;expand&#39;: expand
        }
        
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id),
                                             query_params=query_params)
        
        return PySenseDashboard.Dashboard(self, resp_json)

    def post_dashboards(self, dashboard_json):
        &#34;&#34;&#34;  
        Import given dashboard  

        :param dashboard_json: The dashboard json from the dash file  
        
        :return: The dashboard given by the response object  
        &#34;&#34;&#34;
        
        resp = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/dashboards&#39;, json_payload=dashboard_json)
        return PySenseDashboard.Dashboard(self, resp)

    def delete_dashboards(self, dashboard_id):
        &#34;&#34;&#34;  
        Delete dashboard with id  

        :param dashboard_id: The ID of the dashboard to delete  
        
        :return: The response object  
        &#34;&#34;&#34;
        self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id))

    ############################################
    # Folders                                  #
    ############################################

    def get_folders(self, *, name=None, structure=None, ids=None, fields=None,
                    sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;  
        Provides access to a specified user’s folders in their stored format  
  
        Optional: 
        :param name: Name to filter by  
        :param structure: Structure type of the folders  
        :param ids: Array of folder IDs to get, separated by a comma (,) and without spaces  
        :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
            by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param skip: Number of results to skip from the start of the data set. skip is to be used with the limit  
            parameter for paging  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
        :param expand: List of fields that should be expanded (substitue their IDs with actual objects). May be  
            nested using the resource.subResource format  
            
        :return: An array of folders matching the search criteria  
        &#34;&#34;&#34;
        
        ret_arr = []
        query_params = {
            &#39;name&#39;: name,
            &#39;structure&#39;: structure,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders&#39;, query_params=query_params)

        # Sisense Rest API always returns the root folder, so we filter it out when looking by name
        if name:
            for folder in resp_json:
                if folder[&#39;name&#39;] == name:
                    ret_arr.append(PySenseFolder.Folder(self, folder))
        else:
            for folder in resp_json:
                ret_arr.append(PySenseFolder.Folder(self, folder))
        return ret_arr

    ############################################
    # Groups                                   #
    ############################################

    def get_groups(self, *, name=None, mail=None, role=None, origin=None, ids=None, fields=None,
                   sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;  
        Returns a list of user groups with their details.  
        The results can be filtered by different parameters such as group name or origin.  

        Optional: 
        :param name: Group name to filter by  
        :param mail: Group email to filter by  
        :param role: Group role to filter by  
        :param origin: Group origin to filter by (ad or sisense)  
        :param ids: Array of group IDs to filter by  
        :param fields: Whitelist of fields to return for each document.  
            Fields can also define which fields to exclude by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param skip: Number of results to skip from the start of the data set.  
            Skip is to be used with the limit parameter for paging  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
        :param expand: List of fields that should be expanded (substitures their IDs with actual objects).  
            May be nested using the resource.subResource format  
              
        :return: Array of found groups  
        &#34;&#34;&#34;
        
        query_params = {
            &#39;name&#39;: name,
            &#39;mail&#39;: mail,
            &#39;roleId&#39;: self.get_role_id(role),
            &#39;origin&#39;: origin,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;, query_params=query_params)

        ret_arr = []
        for group in resp_json:
            ret_arr.append(PySenseGroup.Group(self, group))
        return ret_arr

    def get_groups_by_name(self, groups):
        &#34;&#34;&#34;  
        :param groups: A name or list of names 
          
        :return: An array of groups for that name
        &#34;&#34;&#34;
        
        if groups is None:
            return []
        
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;)
        ret = []
        for group in PySenseUtils.make_iterable(groups):
            found = False
            for item in resp_json:
                if group == item[&#39;name&#39;]:
                    ret.append(PySenseGroup.Group(self, item))
                    found = True
            if not found:
                raise PySenseException.PySenseException(&#39;Cannot find group with name {}&#39;.format(group))
        return ret

    def add_groups(self, names):
        &#34;&#34;&#34;  
        Add groups with given names  

        :param names: One to many names 
          
        :return: Array of new groups  
        &#34;&#34;&#34;
        ret_arr = []
        for name in PySenseUtils.make_iterable(names):
            payload = {&#39;name&#39;: name}
            resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/groups&#39;, json_payload=payload)
            ret_arr.append(PySenseGroup.Group(self, resp_json))
        return ret_arr

    def delete_groups(self, groups):
        &#34;&#34;&#34;  
        Delete groups with given names  

        :param groups: Groups to delete
        &#34;&#34;&#34;
        for group in PySenseUtils.make_iterable(groups):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/groups/{}&#39;.format(group.get_id()))

    ############################################
    # Users                                    #
    ############################################

    def add_user(self, email, role, *, user_name=None, first_name=None, last_name=None,
                 groups=[], preferences={}, ui_settings={}):
        &#34;&#34;&#34;  
        Creates that user in SiSense, returning the created object.  

        :param email: email address for user  
        :param role: role of user  
        
        Optional:  
        :param user_name: User user name. Email used if None  
        :param first_name: User first name   
        :param last_name: User last name  
        :param groups: The groups to add the user to  
        :param preferences: User preferences  
        :param ui_settings: User ui settings  
          
        :return: Newly created user object  
        &#34;&#34;&#34;  
        
        user_obj = {
            &#39;email&#39;: email,
            &#39;username&#39;: user_name if user_name is not None else email,
            &#39;roleId&#39;: self.get_role_id(role)
        }

        group_ids = []
        for group in PySenseUtils.make_iterable(groups):
            group_ids.append(group.get_id())
        if len(group_ids) &gt; 0:
            user_obj[&#39;groups&#39;] = group_ids
        
        if first_name is not None:
            user_obj[&#39;firstName&#39;] = first_name
        if last_name is not None:
            user_obj[&#39;lastName&#39;] = last_name
        if preferences is not None:
            user_obj[&#39;preferences&#39;] = preferences
        if ui_settings is not None:
            user_obj[&#39;uiSettings&#39;] = ui_settings
        
        resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/users&#39;, json_payload=user_obj)
        return PySenseUser.User(self, resp_json)

    def get_users(self, *, user_name=None, email=None, first_name=None, last_name=None, role_name=None, group=None,
                  active=None, origin=None, ids=None, fields=None, sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;  
        Returns a list of users with their details.  
        Results can be filtered by parameters such as username and email.  
        The expandable fields for the user object are groups, adgroups and role.  

        Optional:
        :param user_name: Username to filter by  
        :param email: Email to filter by  
        :param first_name: First name to filter by  
        :param last_name: Last name to filter by  
        :param role_name: Role filter by  
        :param group: Group to filter by  
        :param active: User state to filter by (true for active users, false for inactive users)  
        :param origin: User origin to filter by (ad for active directory or sisense)  
        :param ids: Array of user ids to get separated by comma and without spaces  
        :param fields: Whitelist of fields to return for each document.  
            Fields can also define which fields to exclude by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param skip: Number of results to skip from the start of the data set.  
            Skip is to be used with the limit parameter for paging  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
        :param expand: List of fields that should be expanded (substitutes their IDs with actual objects).  
            May be nested using the resource.subResource format  

        :return: An array of users objects  
        &#34;&#34;&#34;
        
        query_params = {
            &#39;userName&#39;: user_name,
            &#39;email&#39;: email,
            &#39;firstName&#39;: first_name,
            &#39;lastName&#39;: last_name,
            &#39;role&#39;: self.get_role_id(role_name),
            &#39;group&#39;: group,
            &#39;active&#39;: active,
            &#39;origin&#39;: origin,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        ret_arr = []
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
        for user in resp_json:
            ret_arr.append((PySenseUser.User(self, user)))
        return ret_arr

    def delete_users(self, users):
        &#34;&#34;&#34;  
        Deletes the specified user or users  
  
        :param users: One to many users to delete
           
        &#34;&#34;&#34;
        for user in PySenseUtils.make_iterable(users):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/users/{}&#39;.format(user.get_id()))

    ############################################
    # Elasticubes                              #
    ############################################

    def get_elasticubes(self):
        &#34;&#34;&#34;  
        Gets elasticubes  
  
        :return: An array of elasticubes   
        &#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/elasticubes/getElasticubes&#39;)
        ret_arr = []
        for cube in resp_json:
            ret_arr.append(PySenseElasticube.Elasticube(self, cube))
        return ret_arr

    def get_elasticube_by_name(self, name):
        &#34;&#34;&#34;  
        Gets elasticube by name  

        :param name: Name of elasticube to get  
        
        :return: A single elasticube with the given name or None if not found  
        &#34;&#34;&#34;
        
        cubes = self.get_elasticubes()  
        for cube in cubes:  
            if cube.get_name() == name:
                return cube
        return None

    ############################################
    # Plug Ins                                 #
    ############################################
    
    def get_plugins(self, *, order_by=None, desc=None, search=None, skip=None, limit=None):
        &#34;&#34;&#34;
        Get all plugins installed  
          
        Optional:  
        :param order_by: Filter by provided field  
        :param desc: Order by descending/ascending (boolean)  
        :param search: Filter according to provided string  
        :param skip: Number of results to skip from the start of the data set. 
            Skip is to be used with the limit parameter for paging.  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging
          
        :return: An array of PySense Plugins Objects
        &#34;&#34;&#34;
        
        query_params = {
            &#39;orderby&#39;: order_by,
            &#39;desc&#39;: desc,
            &#39;search&#39;: search,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        }
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/plugins&#39;, query_params=query_params)
        ret_arr = []
        for plugin in resp_json[&#39;plugins&#39;]:
            ret_arr.append((PySensePlugin.Plugin(self, plugin)))
        return ret_arr

    def get_role_id(self, role_name):
        &#34;&#34;&#34;
        Get the role id for the given role name  

        :param role_name: The role name

        :return: The role id  
        &#34;&#34;&#34;
        if role_name is None:
            return None
        for item in self._roles:
            if role_name == item[&#39;name&#39;] or role_name == item[&#39;displayName&#39;]:
                return item[&#39;_id&#39;]
        raise PySenseException.PySenseException(&#39;No role with name {} found&#39;.format(role_name))

    def get_role_name(self, role_id):
        &#34;&#34;&#34;
        Get the role name for the given role id  

        :param role_id: The role name

        :return: The role name 
        &#34;&#34;&#34;

        for item in self._roles:
            if role_id == item[&#39;_id&#39;]:
                return item[&#39;displayName&#39;]
        raise PySenseException.PySenseException(&#39;No role with id {} found&#39;.format(role_id))

    def get_user_by_email(self, email):
        &#34;&#34;&#34;
        Returns a single user based on email  
        
        :param email: The user&#39;s email
           
        :return: The user associated with the email   
        &#34;&#34;&#34;
        query_params = {&#39;email&#39;: email}
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
        if len(resp_json) == 0:
            raise PySenseException.PySenseException(&#39;No user with email {} found&#39;.format(email))
        elif len(resp_json) &gt; 1:
            raise PySenseException.PySenseException(&#39;{} users with email {} found. &#39;.format(len(resp_json), email))
        else:
            return PySenseUser.User(self, resp_json[0])

    def get_folder_by_id(self, folder_id):
        &#34;&#34;&#34;  
        Get a specific folder by folder id  

        :param folder_id: The folder id of the folder  

        :return: A PySense folder object of the folder or None if not in a folder  
        &#34;&#34;&#34;
        if folder_id is None:
            return None
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders/{}&#39;.format(folder_id))
        return PySenseFolder.Folder(self, resp_json)

    def get_group_by_id(self, group_id):
        &#34;&#34;&#34;
        Get a group by id

        :param group_id: The id of the group  

        :return: The PySense group   
        &#34;&#34;&#34;

        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/groups/{}&#39;.format(group_id))
        return PySenseGroup.Group(self, resp_json)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PySense.PySense.authenticate_by_file"><code class="name flex">
<span>def <span class="ident">authenticate_by_file</span></span>(<span>config_file)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new PySense client with the credentials in the given config file.
</p>
<p>:param config_file: Yaml file with entries for host, username, and password
</p>
<p>:return: A new PySense client for the given credentials</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate_by_file(config_file):
    &#34;&#34;&#34;
    Creates a new PySense client with the credentials in the given config file.  

    :param config_file: Yaml file with entries for host, username, and password  
    
    :return: A new PySense client for the given credentials  
    &#34;&#34;&#34;
    
    with open(config_file, &#39;r&#39;) as yml_file:
        cfg = yaml.safe_load(yml_file)
        debug = cfg[&#39;debug&#39;] if &#39;debug&#39; in cfg else False
        return PySense(cfg[&#39;host&#39;], cfg[&#39;username&#39;], cfg[&#39;password&#39;], debug=debug)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PySense.PySense.PySense"><code class="flex name class">
<span>class <span class="ident">PySense</span></span>
<span>(</span><span>host, username, password, *, debug=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PySense:

    def __init__(self, host, username, password, *, debug=False):
        self.connector = PySenseRestConnector.RestConnector(host, username, password, debug)
        self._roles = self.connector.rest_call(&#39;get&#39;, &#39;api/roles&#39;)
        
    def set_debug(self, debug):
        &#34;&#34;&#34;
        Enable or disable logging of REST api calls to std out. Use for debugging. Debug is false by default.    
          
        :param debug:  True or False to enable or disable debug. 
        &#34;&#34;&#34;
        self.connector.debug = debug

    ############################################
    # Dashboards                               #
    ############################################

    def get_dashboards(self, *, parent_folder=None, name=None, data_source_title=None,
                       data_source_address=None, fields=None, sort=None, expand=None):
        &#34;&#34;&#34;
        Get all dashboards   
          
        Optional:  
        :param parent_folder: Parent folder to filter by  
        :param name: Name to filter by  
        :param data_source_title: Data source name to filter by  
        :param data_source_address: Data source address to filter by  
        :param fields: Whitelist of fields to return for each document.  
           Can also exclude by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param expand: List of fields that should be expanded  
          
        :return: All found dashboards  
        &#34;&#34;&#34;
        
        folder_id = None
        if parent_folder:
            folder_id = parent_folder.get_id()
            
        query_params = {
            &#39;parentFolder&#39;: folder_id,
            &#39;name&#39;: name,
            &#39;datasourceTitle&#39;: data_source_title,
            &#39;datasourceAddress&#39;: data_source_address,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;expand&#39;: expand
        }
        json_arr = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards&#39;, query_params=query_params)
        
        ret_arr = []
        for dash in json_arr:
            ret_arr.append(PySenseDashboard.Dashboard(self, dash))
        return ret_arr

    def get_dashboard_by_id(self, dashboard_id, *, fields=None, expand=None):
        &#34;&#34;&#34;  
        Returns a specific dashboard object by ID.  
  
        :param dashboard_id: The ID of the dashboard to get  
          
        Optional:  
        :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
            by prefixing field names with -  
        :param expand: List of fields that should be expanded (substitures their IDs with actual objects). May be nested
            using the resource.subResource format  
              
        :return: Dashboard with id given  
        &#34;&#34;&#34;
        
        query_params = {
            &#39;fields&#39;: fields,
            &#39;expand&#39;: expand
        }
        
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id),
                                             query_params=query_params)
        
        return PySenseDashboard.Dashboard(self, resp_json)

    def post_dashboards(self, dashboard_json):
        &#34;&#34;&#34;  
        Import given dashboard  

        :param dashboard_json: The dashboard json from the dash file  
        
        :return: The dashboard given by the response object  
        &#34;&#34;&#34;
        
        resp = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/dashboards&#39;, json_payload=dashboard_json)
        return PySenseDashboard.Dashboard(self, resp)

    def delete_dashboards(self, dashboard_id):
        &#34;&#34;&#34;  
        Delete dashboard with id  

        :param dashboard_id: The ID of the dashboard to delete  
        
        :return: The response object  
        &#34;&#34;&#34;
        self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id))

    ############################################
    # Folders                                  #
    ############################################

    def get_folders(self, *, name=None, structure=None, ids=None, fields=None,
                    sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;  
        Provides access to a specified user’s folders in their stored format  
  
        Optional: 
        :param name: Name to filter by  
        :param structure: Structure type of the folders  
        :param ids: Array of folder IDs to get, separated by a comma (,) and without spaces  
        :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
            by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param skip: Number of results to skip from the start of the data set. skip is to be used with the limit  
            parameter for paging  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
        :param expand: List of fields that should be expanded (substitue their IDs with actual objects). May be  
            nested using the resource.subResource format  
            
        :return: An array of folders matching the search criteria  
        &#34;&#34;&#34;
        
        ret_arr = []
        query_params = {
            &#39;name&#39;: name,
            &#39;structure&#39;: structure,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders&#39;, query_params=query_params)

        # Sisense Rest API always returns the root folder, so we filter it out when looking by name
        if name:
            for folder in resp_json:
                if folder[&#39;name&#39;] == name:
                    ret_arr.append(PySenseFolder.Folder(self, folder))
        else:
            for folder in resp_json:
                ret_arr.append(PySenseFolder.Folder(self, folder))
        return ret_arr

    ############################################
    # Groups                                   #
    ############################################

    def get_groups(self, *, name=None, mail=None, role=None, origin=None, ids=None, fields=None,
                   sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;  
        Returns a list of user groups with their details.  
        The results can be filtered by different parameters such as group name or origin.  

        Optional: 
        :param name: Group name to filter by  
        :param mail: Group email to filter by  
        :param role: Group role to filter by  
        :param origin: Group origin to filter by (ad or sisense)  
        :param ids: Array of group IDs to filter by  
        :param fields: Whitelist of fields to return for each document.  
            Fields can also define which fields to exclude by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param skip: Number of results to skip from the start of the data set.  
            Skip is to be used with the limit parameter for paging  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
        :param expand: List of fields that should be expanded (substitures their IDs with actual objects).  
            May be nested using the resource.subResource format  
              
        :return: Array of found groups  
        &#34;&#34;&#34;
        
        query_params = {
            &#39;name&#39;: name,
            &#39;mail&#39;: mail,
            &#39;roleId&#39;: self.get_role_id(role),
            &#39;origin&#39;: origin,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;, query_params=query_params)

        ret_arr = []
        for group in resp_json:
            ret_arr.append(PySenseGroup.Group(self, group))
        return ret_arr

    def get_groups_by_name(self, groups):
        &#34;&#34;&#34;  
        :param groups: A name or list of names 
          
        :return: An array of groups for that name
        &#34;&#34;&#34;
        
        if groups is None:
            return []
        
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;)
        ret = []
        for group in PySenseUtils.make_iterable(groups):
            found = False
            for item in resp_json:
                if group == item[&#39;name&#39;]:
                    ret.append(PySenseGroup.Group(self, item))
                    found = True
            if not found:
                raise PySenseException.PySenseException(&#39;Cannot find group with name {}&#39;.format(group))
        return ret

    def add_groups(self, names):
        &#34;&#34;&#34;  
        Add groups with given names  

        :param names: One to many names 
          
        :return: Array of new groups  
        &#34;&#34;&#34;
        ret_arr = []
        for name in PySenseUtils.make_iterable(names):
            payload = {&#39;name&#39;: name}
            resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/groups&#39;, json_payload=payload)
            ret_arr.append(PySenseGroup.Group(self, resp_json))
        return ret_arr

    def delete_groups(self, groups):
        &#34;&#34;&#34;  
        Delete groups with given names  

        :param groups: Groups to delete
        &#34;&#34;&#34;
        for group in PySenseUtils.make_iterable(groups):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/groups/{}&#39;.format(group.get_id()))

    ############################################
    # Users                                    #
    ############################################

    def add_user(self, email, role, *, user_name=None, first_name=None, last_name=None,
                 groups=[], preferences={}, ui_settings={}):
        &#34;&#34;&#34;  
        Creates that user in SiSense, returning the created object.  

        :param email: email address for user  
        :param role: role of user  
        
        Optional:  
        :param user_name: User user name. Email used if None  
        :param first_name: User first name   
        :param last_name: User last name  
        :param groups: The groups to add the user to  
        :param preferences: User preferences  
        :param ui_settings: User ui settings  
          
        :return: Newly created user object  
        &#34;&#34;&#34;  
        
        user_obj = {
            &#39;email&#39;: email,
            &#39;username&#39;: user_name if user_name is not None else email,
            &#39;roleId&#39;: self.get_role_id(role)
        }

        group_ids = []
        for group in PySenseUtils.make_iterable(groups):
            group_ids.append(group.get_id())
        if len(group_ids) &gt; 0:
            user_obj[&#39;groups&#39;] = group_ids
        
        if first_name is not None:
            user_obj[&#39;firstName&#39;] = first_name
        if last_name is not None:
            user_obj[&#39;lastName&#39;] = last_name
        if preferences is not None:
            user_obj[&#39;preferences&#39;] = preferences
        if ui_settings is not None:
            user_obj[&#39;uiSettings&#39;] = ui_settings
        
        resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/users&#39;, json_payload=user_obj)
        return PySenseUser.User(self, resp_json)

    def get_users(self, *, user_name=None, email=None, first_name=None, last_name=None, role_name=None, group=None,
                  active=None, origin=None, ids=None, fields=None, sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;  
        Returns a list of users with their details.  
        Results can be filtered by parameters such as username and email.  
        The expandable fields for the user object are groups, adgroups and role.  

        Optional:
        :param user_name: Username to filter by  
        :param email: Email to filter by  
        :param first_name: First name to filter by  
        :param last_name: Last name to filter by  
        :param role_name: Role filter by  
        :param group: Group to filter by  
        :param active: User state to filter by (true for active users, false for inactive users)  
        :param origin: User origin to filter by (ad for active directory or sisense)  
        :param ids: Array of user ids to get separated by comma and without spaces  
        :param fields: Whitelist of fields to return for each document.  
            Fields can also define which fields to exclude by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param skip: Number of results to skip from the start of the data set.  
            Skip is to be used with the limit parameter for paging  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
        :param expand: List of fields that should be expanded (substitutes their IDs with actual objects).  
            May be nested using the resource.subResource format  

        :return: An array of users objects  
        &#34;&#34;&#34;
        
        query_params = {
            &#39;userName&#39;: user_name,
            &#39;email&#39;: email,
            &#39;firstName&#39;: first_name,
            &#39;lastName&#39;: last_name,
            &#39;role&#39;: self.get_role_id(role_name),
            &#39;group&#39;: group,
            &#39;active&#39;: active,
            &#39;origin&#39;: origin,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        ret_arr = []
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
        for user in resp_json:
            ret_arr.append((PySenseUser.User(self, user)))
        return ret_arr

    def delete_users(self, users):
        &#34;&#34;&#34;  
        Deletes the specified user or users  
  
        :param users: One to many users to delete
           
        &#34;&#34;&#34;
        for user in PySenseUtils.make_iterable(users):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/users/{}&#39;.format(user.get_id()))

    ############################################
    # Elasticubes                              #
    ############################################

    def get_elasticubes(self):
        &#34;&#34;&#34;  
        Gets elasticubes  
  
        :return: An array of elasticubes   
        &#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/elasticubes/getElasticubes&#39;)
        ret_arr = []
        for cube in resp_json:
            ret_arr.append(PySenseElasticube.Elasticube(self, cube))
        return ret_arr

    def get_elasticube_by_name(self, name):
        &#34;&#34;&#34;  
        Gets elasticube by name  

        :param name: Name of elasticube to get  
        
        :return: A single elasticube with the given name or None if not found  
        &#34;&#34;&#34;
        
        cubes = self.get_elasticubes()  
        for cube in cubes:  
            if cube.get_name() == name:
                return cube
        return None

    ############################################
    # Plug Ins                                 #
    ############################################
    
    def get_plugins(self, *, order_by=None, desc=None, search=None, skip=None, limit=None):
        &#34;&#34;&#34;
        Get all plugins installed  
          
        Optional:  
        :param order_by: Filter by provided field  
        :param desc: Order by descending/ascending (boolean)  
        :param search: Filter according to provided string  
        :param skip: Number of results to skip from the start of the data set. 
            Skip is to be used with the limit parameter for paging.  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging
          
        :return: An array of PySense Plugins Objects
        &#34;&#34;&#34;
        
        query_params = {
            &#39;orderby&#39;: order_by,
            &#39;desc&#39;: desc,
            &#39;search&#39;: search,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        }
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/plugins&#39;, query_params=query_params)
        ret_arr = []
        for plugin in resp_json[&#39;plugins&#39;]:
            ret_arr.append((PySensePlugin.Plugin(self, plugin)))
        return ret_arr

    def get_role_id(self, role_name):
        &#34;&#34;&#34;
        Get the role id for the given role name  

        :param role_name: The role name

        :return: The role id  
        &#34;&#34;&#34;
        if role_name is None:
            return None
        for item in self._roles:
            if role_name == item[&#39;name&#39;] or role_name == item[&#39;displayName&#39;]:
                return item[&#39;_id&#39;]
        raise PySenseException.PySenseException(&#39;No role with name {} found&#39;.format(role_name))

    def get_role_name(self, role_id):
        &#34;&#34;&#34;
        Get the role name for the given role id  

        :param role_id: The role name

        :return: The role name 
        &#34;&#34;&#34;

        for item in self._roles:
            if role_id == item[&#39;_id&#39;]:
                return item[&#39;displayName&#39;]
        raise PySenseException.PySenseException(&#39;No role with id {} found&#39;.format(role_id))

    def get_user_by_email(self, email):
        &#34;&#34;&#34;
        Returns a single user based on email  
        
        :param email: The user&#39;s email
           
        :return: The user associated with the email   
        &#34;&#34;&#34;
        query_params = {&#39;email&#39;: email}
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
        if len(resp_json) == 0:
            raise PySenseException.PySenseException(&#39;No user with email {} found&#39;.format(email))
        elif len(resp_json) &gt; 1:
            raise PySenseException.PySenseException(&#39;{} users with email {} found. &#39;.format(len(resp_json), email))
        else:
            return PySenseUser.User(self, resp_json[0])

    def get_folder_by_id(self, folder_id):
        &#34;&#34;&#34;  
        Get a specific folder by folder id  

        :param folder_id: The folder id of the folder  

        :return: A PySense folder object of the folder or None if not in a folder  
        &#34;&#34;&#34;
        if folder_id is None:
            return None
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders/{}&#39;.format(folder_id))
        return PySenseFolder.Folder(self, resp_json)

    def get_group_by_id(self, group_id):
        &#34;&#34;&#34;
        Get a group by id

        :param group_id: The id of the group  

        :return: The PySense group   
        &#34;&#34;&#34;

        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/groups/{}&#39;.format(group_id))
        return PySenseGroup.Group(self, resp_json)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PySense.PySense.PySense.add_groups"><code class="name flex">
<span>def <span class="ident">add_groups</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<section class="desc"><p>Add groups with given names
</p>
<p>:param names: One to many names </p>
<p>:return: Array of new groups</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_groups(self, names):
    &#34;&#34;&#34;  
    Add groups with given names  

    :param names: One to many names 
      
    :return: Array of new groups  
    &#34;&#34;&#34;
    ret_arr = []
    for name in PySenseUtils.make_iterable(names):
        payload = {&#39;name&#39;: name}
        resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/groups&#39;, json_payload=payload)
        ret_arr.append(PySenseGroup.Group(self, resp_json))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.add_user"><code class="name flex">
<span>def <span class="ident">add_user</span></span>(<span>self, email, role, *, user_name=None, first_name=None, last_name=None, groups=[], preferences={}, ui_settings={})</span>
</code></dt>
<dd>
<section class="desc"><p>Creates that user in SiSense, returning the created object.
</p>
<p>:param email: email address for user<br>
:param role: role of user
</p>
<p>Optional:<br>
:param user_name: User user name. Email used if None<br>
:param first_name: User first name <br>
:param last_name: User last name<br>
:param groups: The groups to add the user to<br>
:param preferences: User preferences<br>
:param ui_settings: User ui settings
</p>
<p>:return: Newly created user object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_user(self, email, role, *, user_name=None, first_name=None, last_name=None,
             groups=[], preferences={}, ui_settings={}):
    &#34;&#34;&#34;  
    Creates that user in SiSense, returning the created object.  

    :param email: email address for user  
    :param role: role of user  
    
    Optional:  
    :param user_name: User user name. Email used if None  
    :param first_name: User first name   
    :param last_name: User last name  
    :param groups: The groups to add the user to  
    :param preferences: User preferences  
    :param ui_settings: User ui settings  
      
    :return: Newly created user object  
    &#34;&#34;&#34;  
    
    user_obj = {
        &#39;email&#39;: email,
        &#39;username&#39;: user_name if user_name is not None else email,
        &#39;roleId&#39;: self.get_role_id(role)
    }

    group_ids = []
    for group in PySenseUtils.make_iterable(groups):
        group_ids.append(group.get_id())
    if len(group_ids) &gt; 0:
        user_obj[&#39;groups&#39;] = group_ids
    
    if first_name is not None:
        user_obj[&#39;firstName&#39;] = first_name
    if last_name is not None:
        user_obj[&#39;lastName&#39;] = last_name
    if preferences is not None:
        user_obj[&#39;preferences&#39;] = preferences
    if ui_settings is not None:
        user_obj[&#39;uiSettings&#39;] = ui_settings
    
    resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/users&#39;, json_payload=user_obj)
    return PySenseUser.User(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.delete_dashboards"><code class="name flex">
<span>def <span class="ident">delete_dashboards</span></span>(<span>self, dashboard_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete dashboard with id
</p>
<p>:param dashboard_id: The ID of the dashboard to delete
</p>
<p>:return: The response object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_dashboards(self, dashboard_id):
    &#34;&#34;&#34;  
    Delete dashboard with id  

    :param dashboard_id: The ID of the dashboard to delete  
    
    :return: The response object  
    &#34;&#34;&#34;
    self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.delete_groups"><code class="name flex">
<span>def <span class="ident">delete_groups</span></span>(<span>self, groups)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete groups with given names
</p>
<p>:param groups: Groups to delete</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_groups(self, groups):
    &#34;&#34;&#34;  
    Delete groups with given names  

    :param groups: Groups to delete
    &#34;&#34;&#34;
    for group in PySenseUtils.make_iterable(groups):
        self.connector.rest_call(&#39;delete&#39;, &#39;api/groups/{}&#39;.format(group.get_id()))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.delete_users"><code class="name flex">
<span>def <span class="ident">delete_users</span></span>(<span>self, users)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes the specified user or users
</p>
<p>:param users: One to many users to delete</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_users(self, users):
    &#34;&#34;&#34;  
    Deletes the specified user or users  

    :param users: One to many users to delete
       
    &#34;&#34;&#34;
    for user in PySenseUtils.make_iterable(users):
        self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/users/{}&#39;.format(user.get_id()))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_dashboard_by_id"><code class="name flex">
<span>def <span class="ident">get_dashboard_by_id</span></span>(<span>self, dashboard_id, *, fields=None, expand=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a specific dashboard object by ID.
</p>
<p>:param dashboard_id: The ID of the dashboard to get
</p>
<p>Optional:<br>
:param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
by prefixing field names with -<br>
:param expand: List of fields that should be expanded (substitures their IDs with actual objects). May be nested
using the resource.subResource format
</p>
<p>:return: Dashboard with id given</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_by_id(self, dashboard_id, *, fields=None, expand=None):
    &#34;&#34;&#34;  
    Returns a specific dashboard object by ID.  

    :param dashboard_id: The ID of the dashboard to get  
      
    Optional:  
    :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
        by prefixing field names with -  
    :param expand: List of fields that should be expanded (substitures their IDs with actual objects). May be nested
        using the resource.subResource format  
          
    :return: Dashboard with id given  
    &#34;&#34;&#34;
    
    query_params = {
        &#39;fields&#39;: fields,
        &#39;expand&#39;: expand
    }
    
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id),
                                         query_params=query_params)
    
    return PySenseDashboard.Dashboard(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_dashboards"><code class="name flex">
<span>def <span class="ident">get_dashboards</span></span>(<span>self, *, parent_folder=None, name=None, data_source_title=None, data_source_address=None, fields=None, sort=None, expand=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get all dashboards
</p>
<p>Optional:<br>
:param parent_folder: Parent folder to filter by<br>
:param name: Name to filter by<br>
:param data_source_title: Data source name to filter by<br>
:param data_source_address: Data source address to filter by<br>
:param fields: Whitelist of fields to return for each document.<br>
Can also exclude by prefixing field names with -<br>
:param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -<br>
:param expand: List of fields that should be expanded
</p>
<p>:return: All found dashboards</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboards(self, *, parent_folder=None, name=None, data_source_title=None,
                   data_source_address=None, fields=None, sort=None, expand=None):
    &#34;&#34;&#34;
    Get all dashboards   
      
    Optional:  
    :param parent_folder: Parent folder to filter by  
    :param name: Name to filter by  
    :param data_source_title: Data source name to filter by  
    :param data_source_address: Data source address to filter by  
    :param fields: Whitelist of fields to return for each document.  
       Can also exclude by prefixing field names with -  
    :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
    :param expand: List of fields that should be expanded  
      
    :return: All found dashboards  
    &#34;&#34;&#34;
    
    folder_id = None
    if parent_folder:
        folder_id = parent_folder.get_id()
        
    query_params = {
        &#39;parentFolder&#39;: folder_id,
        &#39;name&#39;: name,
        &#39;datasourceTitle&#39;: data_source_title,
        &#39;datasourceAddress&#39;: data_source_address,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;expand&#39;: expand
    }
    json_arr = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards&#39;, query_params=query_params)
    
    ret_arr = []
    for dash in json_arr:
        ret_arr.append(PySenseDashboard.Dashboard(self, dash))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_elasticube_by_name"><code class="name flex">
<span>def <span class="ident">get_elasticube_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets elasticube by name
</p>
<p>:param name: Name of elasticube to get
</p>
<p>:return: A single elasticube with the given name or None if not found</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elasticube_by_name(self, name):
    &#34;&#34;&#34;  
    Gets elasticube by name  

    :param name: Name of elasticube to get  
    
    :return: A single elasticube with the given name or None if not found  
    &#34;&#34;&#34;
    
    cubes = self.get_elasticubes()  
    for cube in cubes:  
        if cube.get_name() == name:
            return cube
    return None</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_elasticubes"><code class="name flex">
<span>def <span class="ident">get_elasticubes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets elasticubes
</p>
<p>:return: An array of elasticubes</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elasticubes(self):
    &#34;&#34;&#34;  
    Gets elasticubes  

    :return: An array of elasticubes   
    &#34;&#34;&#34;
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/elasticubes/getElasticubes&#39;)
    ret_arr = []
    for cube in resp_json:
        ret_arr.append(PySenseElasticube.Elasticube(self, cube))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_folder_by_id"><code class="name flex">
<span>def <span class="ident">get_folder_by_id</span></span>(<span>self, folder_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a specific folder by folder id
</p>
<p>:param folder_id: The folder id of the folder
</p>
<p>:return: A PySense folder object of the folder or None if not in a folder</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folder_by_id(self, folder_id):
    &#34;&#34;&#34;  
    Get a specific folder by folder id  

    :param folder_id: The folder id of the folder  

    :return: A PySense folder object of the folder or None if not in a folder  
    &#34;&#34;&#34;
    if folder_id is None:
        return None
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders/{}&#39;.format(folder_id))
    return PySenseFolder.Folder(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_folders"><code class="name flex">
<span>def <span class="ident">get_folders</span></span>(<span>self, *, name=None, structure=None, ids=None, fields=None, sort=None, skip=None, limit=None, expand=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Provides access to a specified user’s folders in their stored format
</p>
<p>Optional:
:param name: Name to filter by<br>
:param structure: Structure type of the folders<br>
:param ids: Array of folder IDs to get, separated by a comma (,) and without spaces<br>
:param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude<br>
by prefixing field names with -<br>
:param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -<br>
:param skip: Number of results to skip from the start of the data set. skip is to be used with the limit<br>
parameter for paging<br>
:param limit: How many results should be returned. limit is to be used with the skip parameter for paging<br>
:param expand: List of fields that should be expanded (substitue their IDs with actual objects). May be<br>
nested using the resource.subResource format
</p>
<p>:return: An array of folders matching the search criteria</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folders(self, *, name=None, structure=None, ids=None, fields=None,
                sort=None, skip=None, limit=None, expand=None):
    &#34;&#34;&#34;  
    Provides access to a specified user’s folders in their stored format  

    Optional: 
    :param name: Name to filter by  
    :param structure: Structure type of the folders  
    :param ids: Array of folder IDs to get, separated by a comma (,) and without spaces  
    :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
        by prefixing field names with -  
    :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
    :param skip: Number of results to skip from the start of the data set. skip is to be used with the limit  
        parameter for paging  
    :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
    :param expand: List of fields that should be expanded (substitue their IDs with actual objects). May be  
        nested using the resource.subResource format  
        
    :return: An array of folders matching the search criteria  
    &#34;&#34;&#34;
    
    ret_arr = []
    query_params = {
        &#39;name&#39;: name,
        &#39;structure&#39;: structure,
        &#39;ids&#39;: ids,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit,
        &#39;expand&#39;: expand
    }
    
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders&#39;, query_params=query_params)

    # Sisense Rest API always returns the root folder, so we filter it out when looking by name
    if name:
        for folder in resp_json:
            if folder[&#39;name&#39;] == name:
                ret_arr.append(PySenseFolder.Folder(self, folder))
    else:
        for folder in resp_json:
            ret_arr.append(PySenseFolder.Folder(self, folder))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_group_by_id"><code class="name flex">
<span>def <span class="ident">get_group_by_id</span></span>(<span>self, group_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a group by id</p>
<p>:param group_id: The id of the group
</p>
<p>:return: The PySense group</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group_by_id(self, group_id):
    &#34;&#34;&#34;
    Get a group by id

    :param group_id: The id of the group  

    :return: The PySense group   
    &#34;&#34;&#34;

    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/groups/{}&#39;.format(group_id))
    return PySenseGroup.Group(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_groups"><code class="name flex">
<span>def <span class="ident">get_groups</span></span>(<span>self, *, name=None, mail=None, role=None, origin=None, ids=None, fields=None, sort=None, skip=None, limit=None, expand=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of user groups with their details.<br>
The results can be filtered by different parameters such as group name or origin.
</p>
<p>Optional:
:param name: Group name to filter by<br>
:param mail: Group email to filter by<br>
:param role: Group role to filter by<br>
:param origin: Group origin to filter by (ad or sisense)<br>
:param ids: Array of group IDs to filter by<br>
:param fields: Whitelist of fields to return for each document.<br>
Fields can also define which fields to exclude by prefixing field names with -<br>
:param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -<br>
:param skip: Number of results to skip from the start of the data set.<br>
Skip is to be used with the limit parameter for paging<br>
:param limit: How many results should be returned. limit is to be used with the skip parameter for paging<br>
:param expand: List of fields that should be expanded (substitures their IDs with actual objects).<br>
May be nested using the resource.subResource format
</p>
<p>:return: Array of found groups</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_groups(self, *, name=None, mail=None, role=None, origin=None, ids=None, fields=None,
               sort=None, skip=None, limit=None, expand=None):
    &#34;&#34;&#34;  
    Returns a list of user groups with their details.  
    The results can be filtered by different parameters such as group name or origin.  

    Optional: 
    :param name: Group name to filter by  
    :param mail: Group email to filter by  
    :param role: Group role to filter by  
    :param origin: Group origin to filter by (ad or sisense)  
    :param ids: Array of group IDs to filter by  
    :param fields: Whitelist of fields to return for each document.  
        Fields can also define which fields to exclude by prefixing field names with -  
    :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
    :param skip: Number of results to skip from the start of the data set.  
        Skip is to be used with the limit parameter for paging  
    :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
    :param expand: List of fields that should be expanded (substitures their IDs with actual objects).  
        May be nested using the resource.subResource format  
          
    :return: Array of found groups  
    &#34;&#34;&#34;
    
    query_params = {
        &#39;name&#39;: name,
        &#39;mail&#39;: mail,
        &#39;roleId&#39;: self.get_role_id(role),
        &#39;origin&#39;: origin,
        &#39;ids&#39;: ids,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit,
        &#39;expand&#39;: expand
    }
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;, query_params=query_params)

    ret_arr = []
    for group in resp_json:
        ret_arr.append(PySenseGroup.Group(self, group))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_groups_by_name"><code class="name flex">
<span>def <span class="ident">get_groups_by_name</span></span>(<span>self, groups)</span>
</code></dt>
<dd>
<section class="desc"><p>:param groups: A name or list of names </p>
<p>:return: An array of groups for that name</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_groups_by_name(self, groups):
    &#34;&#34;&#34;  
    :param groups: A name or list of names 
      
    :return: An array of groups for that name
    &#34;&#34;&#34;
    
    if groups is None:
        return []
    
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;)
    ret = []
    for group in PySenseUtils.make_iterable(groups):
        found = False
        for item in resp_json:
            if group == item[&#39;name&#39;]:
                ret.append(PySenseGroup.Group(self, item))
                found = True
        if not found:
            raise PySenseException.PySenseException(&#39;Cannot find group with name {}&#39;.format(group))
    return ret</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_plugins"><code class="name flex">
<span>def <span class="ident">get_plugins</span></span>(<span>self, *, order_by=None, desc=None, search=None, skip=None, limit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get all plugins installed
</p>
<p>Optional:<br>
:param order_by: Filter by provided field<br>
:param desc: Order by descending/ascending (boolean)<br>
:param search: Filter according to provided string<br>
:param skip: Number of results to skip from the start of the data set.
Skip is to be used with the limit parameter for paging.<br>
:param limit: How many results should be returned. limit is to be used with the skip parameter for paging</p>
<p>:return: An array of PySense Plugins Objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plugins(self, *, order_by=None, desc=None, search=None, skip=None, limit=None):
    &#34;&#34;&#34;
    Get all plugins installed  
      
    Optional:  
    :param order_by: Filter by provided field  
    :param desc: Order by descending/ascending (boolean)  
    :param search: Filter according to provided string  
    :param skip: Number of results to skip from the start of the data set. 
        Skip is to be used with the limit parameter for paging.  
    :param limit: How many results should be returned. limit is to be used with the skip parameter for paging
      
    :return: An array of PySense Plugins Objects
    &#34;&#34;&#34;
    
    query_params = {
        &#39;orderby&#39;: order_by,
        &#39;desc&#39;: desc,
        &#39;search&#39;: search,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit
    }
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/plugins&#39;, query_params=query_params)
    ret_arr = []
    for plugin in resp_json[&#39;plugins&#39;]:
        ret_arr.append((PySensePlugin.Plugin(self, plugin)))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_role_id"><code class="name flex">
<span>def <span class="ident">get_role_id</span></span>(<span>self, role_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the role id for the given role name
</p>
<p>:param role_name: The role name</p>
<p>:return: The role id</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_role_id(self, role_name):
    &#34;&#34;&#34;
    Get the role id for the given role name  

    :param role_name: The role name

    :return: The role id  
    &#34;&#34;&#34;
    if role_name is None:
        return None
    for item in self._roles:
        if role_name == item[&#39;name&#39;] or role_name == item[&#39;displayName&#39;]:
            return item[&#39;_id&#39;]
    raise PySenseException.PySenseException(&#39;No role with name {} found&#39;.format(role_name))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_role_name"><code class="name flex">
<span>def <span class="ident">get_role_name</span></span>(<span>self, role_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the role name for the given role id
</p>
<p>:param role_id: The role name</p>
<p>:return: The role name</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_role_name(self, role_id):
    &#34;&#34;&#34;
    Get the role name for the given role id  

    :param role_id: The role name

    :return: The role name 
    &#34;&#34;&#34;

    for item in self._roles:
        if role_id == item[&#39;_id&#39;]:
            return item[&#39;displayName&#39;]
    raise PySenseException.PySenseException(&#39;No role with id {} found&#39;.format(role_id))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_user_by_email"><code class="name flex">
<span>def <span class="ident">get_user_by_email</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a single user based on email
</p>
<p>:param email: The user's email</p>
<p>:return: The user associated with the email</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_by_email(self, email):
    &#34;&#34;&#34;
    Returns a single user based on email  
    
    :param email: The user&#39;s email
       
    :return: The user associated with the email   
    &#34;&#34;&#34;
    query_params = {&#39;email&#39;: email}
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
    if len(resp_json) == 0:
        raise PySenseException.PySenseException(&#39;No user with email {} found&#39;.format(email))
    elif len(resp_json) &gt; 1:
        raise PySenseException.PySenseException(&#39;{} users with email {} found. &#39;.format(len(resp_json), email))
    else:
        return PySenseUser.User(self, resp_json[0])</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_users"><code class="name flex">
<span>def <span class="ident">get_users</span></span>(<span>self, *, user_name=None, email=None, first_name=None, last_name=None, role_name=None, group=None, active=None, origin=None, ids=None, fields=None, sort=None, skip=None, limit=None, expand=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of users with their details.<br>
Results can be filtered by parameters such as username and email.<br>
The expandable fields for the user object are groups, adgroups and role.
</p>
<p>Optional:
:param user_name: Username to filter by<br>
:param email: Email to filter by<br>
:param first_name: First name to filter by<br>
:param last_name: Last name to filter by<br>
:param role_name: Role filter by<br>
:param group: Group to filter by<br>
:param active: User state to filter by (true for active users, false for inactive users)<br>
:param origin: User origin to filter by (ad for active directory or sisense)<br>
:param ids: Array of user ids to get separated by comma and without spaces<br>
:param fields: Whitelist of fields to return for each document.<br>
Fields can also define which fields to exclude by prefixing field names with -<br>
:param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -<br>
:param skip: Number of results to skip from the start of the data set.<br>
Skip is to be used with the limit parameter for paging<br>
:param limit: How many results should be returned. limit is to be used with the skip parameter for paging<br>
:param expand: List of fields that should be expanded (substitutes their IDs with actual objects).<br>
May be nested using the resource.subResource format
</p>
<p>:return: An array of users objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users(self, *, user_name=None, email=None, first_name=None, last_name=None, role_name=None, group=None,
              active=None, origin=None, ids=None, fields=None, sort=None, skip=None, limit=None, expand=None):
    &#34;&#34;&#34;  
    Returns a list of users with their details.  
    Results can be filtered by parameters such as username and email.  
    The expandable fields for the user object are groups, adgroups and role.  

    Optional:
    :param user_name: Username to filter by  
    :param email: Email to filter by  
    :param first_name: First name to filter by  
    :param last_name: Last name to filter by  
    :param role_name: Role filter by  
    :param group: Group to filter by  
    :param active: User state to filter by (true for active users, false for inactive users)  
    :param origin: User origin to filter by (ad for active directory or sisense)  
    :param ids: Array of user ids to get separated by comma and without spaces  
    :param fields: Whitelist of fields to return for each document.  
        Fields can also define which fields to exclude by prefixing field names with -  
    :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
    :param skip: Number of results to skip from the start of the data set.  
        Skip is to be used with the limit parameter for paging  
    :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
    :param expand: List of fields that should be expanded (substitutes their IDs with actual objects).  
        May be nested using the resource.subResource format  

    :return: An array of users objects  
    &#34;&#34;&#34;
    
    query_params = {
        &#39;userName&#39;: user_name,
        &#39;email&#39;: email,
        &#39;firstName&#39;: first_name,
        &#39;lastName&#39;: last_name,
        &#39;role&#39;: self.get_role_id(role_name),
        &#39;group&#39;: group,
        &#39;active&#39;: active,
        &#39;origin&#39;: origin,
        &#39;ids&#39;: ids,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit,
        &#39;expand&#39;: expand
    }
    ret_arr = []
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
    for user in resp_json:
        ret_arr.append((PySenseUser.User(self, user)))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.post_dashboards"><code class="name flex">
<span>def <span class="ident">post_dashboards</span></span>(<span>self, dashboard_json)</span>
</code></dt>
<dd>
<section class="desc"><p>Import given dashboard
</p>
<p>:param dashboard_json: The dashboard json from the dash file
</p>
<p>:return: The dashboard given by the response object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_dashboards(self, dashboard_json):
    &#34;&#34;&#34;  
    Import given dashboard  

    :param dashboard_json: The dashboard json from the dash file  
    
    :return: The dashboard given by the response object  
    &#34;&#34;&#34;
    
    resp = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/dashboards&#39;, json_payload=dashboard_json)
    return PySenseDashboard.Dashboard(self, resp)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.set_debug"><code class="name flex">
<span>def <span class="ident">set_debug</span></span>(<span>self, debug)</span>
</code></dt>
<dd>
<section class="desc"><p>Enable or disable logging of REST api calls to std out. Use for debugging. Debug is false by default.
</p>
<p>:param debug:
True or False to enable or disable debug.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_debug(self, debug):
    &#34;&#34;&#34;
    Enable or disable logging of REST api calls to std out. Use for debugging. Debug is false by default.    
      
    :param debug:  True or False to enable or disable debug. 
    &#34;&#34;&#34;
    self.connector.debug = debug</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PySense" href="index.html">PySense</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PySense.PySense.authenticate_by_file" href="#PySense.PySense.authenticate_by_file">authenticate_by_file</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PySense.PySense.PySense" href="#PySense.PySense.PySense">PySense</a></code></h4>
<ul class="">
<li><code><a title="PySense.PySense.PySense.add_groups" href="#PySense.PySense.PySense.add_groups">add_groups</a></code></li>
<li><code><a title="PySense.PySense.PySense.add_user" href="#PySense.PySense.PySense.add_user">add_user</a></code></li>
<li><code><a title="PySense.PySense.PySense.delete_dashboards" href="#PySense.PySense.PySense.delete_dashboards">delete_dashboards</a></code></li>
<li><code><a title="PySense.PySense.PySense.delete_groups" href="#PySense.PySense.PySense.delete_groups">delete_groups</a></code></li>
<li><code><a title="PySense.PySense.PySense.delete_users" href="#PySense.PySense.PySense.delete_users">delete_users</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_dashboard_by_id" href="#PySense.PySense.PySense.get_dashboard_by_id">get_dashboard_by_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_dashboards" href="#PySense.PySense.PySense.get_dashboards">get_dashboards</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_elasticube_by_name" href="#PySense.PySense.PySense.get_elasticube_by_name">get_elasticube_by_name</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_elasticubes" href="#PySense.PySense.PySense.get_elasticubes">get_elasticubes</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_folder_by_id" href="#PySense.PySense.PySense.get_folder_by_id">get_folder_by_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_folders" href="#PySense.PySense.PySense.get_folders">get_folders</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_group_by_id" href="#PySense.PySense.PySense.get_group_by_id">get_group_by_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_groups" href="#PySense.PySense.PySense.get_groups">get_groups</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_groups_by_name" href="#PySense.PySense.PySense.get_groups_by_name">get_groups_by_name</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_plugins" href="#PySense.PySense.PySense.get_plugins">get_plugins</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_role_id" href="#PySense.PySense.PySense.get_role_id">get_role_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_role_name" href="#PySense.PySense.PySense.get_role_name">get_role_name</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_user_by_email" href="#PySense.PySense.PySense.get_user_by_email">get_user_by_email</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_users" href="#PySense.PySense.PySense.get_users">get_users</a></code></li>
<li><code><a title="PySense.PySense.PySense.post_dashboards" href="#PySense.PySense.PySense.post_dashboards">post_dashboards</a></code></li>
<li><code><a title="PySense.PySense.PySense.set_debug" href="#PySense.PySense.PySense.set_debug">set_debug</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>