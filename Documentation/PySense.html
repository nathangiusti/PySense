<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>PySense.PySense API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PySense.PySense</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PySense import PySenseAuthentication
from PySense import PySenseBranding
from PySense import PySenseConnection
from PySense import PySenseDashboard
from PySense import PySenseDataModel
from PySense import PySenseElasticube
from PySense import PySenseException
from PySense import PySenseGroup
from PySense import PySenseFolder
from PySense import PySensePlugin
from PySense import PySenseRestConnector
from PySense import PySenseUser
from PySense import PySenseUtils
from PySense import SisenseVersion


def authenticate_by_token(host, token, version, debug=False, verify=True):
    &#34;&#34;&#34;Creates a new PySense client with the token

    Args:
        - host: The Sisense server address
        - token: A Sisense user token
        - version: &#39;Windows&#39; or &#39;Linux&#39;
        - debug: (Optional) True to enable debugging. False by default.
        - verify: (Optional) False to disable SSL certificate verification. True by default.


    Returns:
        A new PySense client for the given credentials
    &#34;&#34;&#34;
    return PySenseAuthentication.authenticate_by_token(host, token, version, debug, verify)


def authenticate_by_password(host, username, password, version, debug=False, verify=True):
    &#34;&#34;&#34;Creates a new PySense client with the username and password

    Args:
        - host: The Sisense server address
        - username: Sisense username
        - password: Sisense password
        - version: &#39;Windows&#39; or &#39;Linux&#39;
        - debug: (Optional) True to enable debugging. False by default.
        - verify: (Optional) False to disable SSL certificate verification. True by default.


    Returns:
        A new PySense client for the given credentials
    &#34;&#34;&#34;
    return PySenseAuthentication.authenticate_by_password(host, username, password, version, debug, verify)


def authenticate_by_file(config_file):
    &#34;&#34;&#34;Creates a new PySense client with the credentials in the given config file.

    py_client = PySense.authenticate_by_file(&#39;C:\\PySense\\PySenseConfig.yaml&#39;)

    See sample config in Snippets/SampleConfig.yaml

    Args:
        config_file: Yaml file with credentials

    Returns:
        A new PySense client for the given credentials
    &#34;&#34;&#34;
    return PySenseAuthentication.authenticate_by_file(config_file)


class PySense:
    &#34;&#34;&#34;The manager of connections to the PySense server

    This class is for sever level changes like getting, adding, and removing dashboards, elasticubes, users, etc

    Attributes:
        connector: The PySenseRestConnector which runs the rest commands.
    &#34;&#34;&#34;

    def __init__(self, host, token, version, *, debug=False, verify=True):
        &#34;&#34;&#34; Initializes a PySense instance

        Args:
            host: host address
            token: a json bearer token with format
                {&#39;authorization&#39;:  &#34;Bearer yourlongaccesstokenstringthatyougotfromapreviouslogin&#34;}
            version: version (either &#39;Windows&#39; or &#39;Linux&#39;)
            debug: If true, prints detailed REST API logs to console. False by default.
            verify: If false, disables SSL Certification. True by default.
        &#34;&#34;&#34;
        if version.lower() == &#39;windows&#39;:
            self.version = SisenseVersion.Version.WINDOWS
        elif version.lower() == &#39;linux&#39;:
            self.version = SisenseVersion.Version.LINUX
        else:
            raise PySenseException.PySenseException(&#39;{} not a valid OS. Please select Linux or Windows&#39;.format(version))

        self.connector = PySenseRestConnector.RestConnector(host, token, debug, verify)
        self._roles = self.connector.rest_call(&#39;get&#39;, &#39;api/roles&#39;)

    def set_debug(self, debug):
        &#34;&#34;&#34;Enable or disable logging of REST api calls to std out.

        Use for debugging. Debug is false by default.
        &#34;&#34;&#34;
        self.connector.debug = debug

    ############################################
    # Dashboards                               #
    ############################################

    def get_dashboards(self, *, parent_folder=None, name=None, data_source_title=None,
                       data_source_address=None, fields=None, sort=None, expand=None):
        &#34;&#34;&#34;Get all dashboards.

        Args:
            parent_folder: Parent folder to filter by
            name: Name to filter by
            data_source_title: Data source name to filter by
            data_source_address: Data source address to filter by
            fields: Whitelist of fields to return for each document.
               Can also exclude by prefixing field names with -
            sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
            expand: List of fields that should be expanded

        Returns:
            An array of all found dashboards
        &#34;&#34;&#34;

        folder_id = None
        if parent_folder:
            folder_id = parent_folder.get_id()

        query_params = {
            &#39;parentFolder&#39;: folder_id,
            &#39;name&#39;: name,
            &#39;datasourceTitle&#39;: data_source_title,
            &#39;datasourceAddress&#39;: data_source_address,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;expand&#39;: expand
        }
        json_arr = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards&#39;, query_params=query_params)

        ret_arr = []
        for dash in json_arr:
            ret_arr.append(PySenseDashboard.Dashboard(self, dash))
        return ret_arr

    def get_dashboard_by_id(self, dashboard_id, *, fields=None, expand=None):
        &#34;&#34;&#34;Returns a specific dashboard object by ID.

        Args:
            dashboard_id: The ID of the dashboard to get
            fields: (optional) Whitelist of fields to return for each document.
                Fields Can also define which fields to exclude by prefixing field names with -
            expand: (optional) List of fields that should be expanded (substitues their IDs with actual objects).
                May be nested using the resource.subResource format

        Returns:
             Dashboard with the given id.
        &#34;&#34;&#34;

        query_params = {
            &#39;fields&#39;: fields,
            &#39;expand&#39;: expand
        }

        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id),
                                             query_params=query_params)

        return PySenseDashboard.Dashboard(self, resp_json)

    def add_dashboards(self, dashboards):
        &#34;&#34;&#34;Import given dashboards.

        Args:
            dashboards: One to many PySense dashboard to import

        Returns:
            An array of new dashboards
        &#34;&#34;&#34;
        ret_arr = []
        for dashboard in PySenseUtils.make_iterable(dashboards):
            resp = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/dashboards&#39;, json_payload=dashboard.get_json())
            ret_arr.append(PySenseDashboard.Dashboard(self, resp))
        return ret_arr

    def delete_dashboards(self, dashboards):
        &#34;&#34;&#34;Delete dashboards.

        Args:
            dashboards: Dashboards to delete
        &#34;&#34;&#34;
        for dashboard in PySenseUtils.make_iterable(dashboards):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard.get_id()))

    ############################################
    # Folders                                  #
    ############################################

    def get_folders(self, *, name=None, structure=None, ids=None, fields=None,
                    sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;Provides access to a specified user’s folders in their stored format.

        Args:
            name: (optional) Name to filter by
            structure: (optional) Structure type of the folders
            ids: (optional) Array of folder IDs to get, separated by a comma (,) and without spaces
            fields: (optional) Whitelist of fields to return for each document.
                Fields Can also define which fields to exclude by prefixing field names with -
            sort: (optional) Field by which the results should be sorted.
                Ascending by default, descending if prefixed by -
            skip: (optional) Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging
            limit: (optional) How many results should be returned.
                limit is to be used with the skip parameter for paging
            expand: (optional) List of fields that should be expanded (substitue their IDs with actual objects).
                May be nested using the resource.subResource format

        Returns:
             An array of folders matching the search criteria
        &#34;&#34;&#34;
        ret_arr = []
        query_params = {
            &#39;name&#39;: name,
            &#39;structure&#39;: structure,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }

        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders&#39;, query_params=query_params)

        # Sisense Rest API always returns the root folder, so we filter it out when looking by name
        if name:
            for folder in resp_json:
                if folder[&#39;name&#39;] == name:
                    ret_arr.append(PySenseFolder.Folder(self, folder))
        else:
            for folder in resp_json:
                ret_arr.append(PySenseFolder.Folder(self, folder))
        return ret_arr

    def get_folder_by_id(self, folder_id):
        &#34;&#34;&#34;Get a specific folder by folder id.&#34;&#34;&#34;
        if folder_id is None:
            return None
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders/{}&#39;.format(folder_id))
        return PySenseFolder.Folder(self, resp_json)

    ############################################
    # Groups                                   #
    ############################################

    def get_groups(self, *, name=None, mail=None, role=None, origin=None, ids=None, fields=None,
                   sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;Returns a list of user groups with their details.
        The results can be filtered by different parameters such as group name or origin.

        Args:
            name: (optional) Group name to filter by
            mail: (optional) Group email to filter by
            role: (optional) Group role to filter by
            origin: (optional) Group origin to filter by (ad or sisense)
            ids: (optional) Array of group IDs to filter by
            fields: (optional) Whitelist of fields to return for each document.
                Fields can also define which fields to exclude by prefixing field names with -
            sort: (optional) Field by which the results should be sorted.
                Ascending by default, descending if prefixed by -
            skip: (optional) Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging
            limit: (optional) How many results should be returned.
                limit is to be used with the skip parameter for paging
            expand: (optional) List of fields that should be expanded (substitures their IDs with actual objects).
                May be nested using the resource.subResource format

        Returns:
            Array of found groups
        &#34;&#34;&#34;

        query_params = {
            &#39;name&#39;: name,
            &#39;mail&#39;: mail,
            &#39;roleId&#39;: self.get_role_id(role),
            &#39;origin&#39;: origin,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;, query_params=query_params)

        ret_arr = []
        for group in resp_json:
            ret_arr.append(PySenseGroup.Group(self, group))
        return ret_arr

    def get_group_by_id(self, group_id):
        &#34;&#34;&#34;Get a group by id&#34;&#34;&#34;
        if group_id is None:
            return None
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/groups/{}&#39;.format(group_id))
        return PySenseGroup.Group(self, resp_json)

    def get_groups_by_name(self, group_names):
        &#34;&#34;&#34;Returns an array of groups matching the given names

        Args:
            group_names: One to many group names
        &#34;&#34;&#34;
        if group_names is None:
            return []

        server_groups = self.get_groups()
        ret = []
        group_names = PySenseUtils.make_iterable(group_names)
        for group in server_groups:
            if group.get_name() in group_names:
                ret.append(group)
        return ret

    def add_groups(self, names):
        &#34;&#34;&#34;Add groups with given names.

        Args:
            names: One to many names

        Returns:
            Array of new groups
        &#34;&#34;&#34;
        ret_arr = []
        for name in PySenseUtils.make_iterable(names):
            payload = {&#39;name&#39;: name}
            resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/groups&#39;, json_payload=payload)
            ret_arr.append(PySenseGroup.Group(self, resp_json))
        return ret_arr

    def delete_groups(self, groups):
        &#34;&#34;&#34;Delete groups.

        Args:
            groups: One to many groups to delete
        &#34;&#34;&#34;
        for group in PySenseUtils.make_iterable(groups):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/groups/{}&#39;.format(group.get_id()))

    ############################################
    # Users                                    #
    ############################################

    def add_user(self, email, role, *, user_name=None, first_name=None, last_name=None,
                 groups=[], preferences={}, ui_settings={}):
        &#34;&#34;&#34;Creates a user in Sisense.

        Args:
            email: email address for user
            role: role of user
            user_name: (optional) User user name. Email used if None
            first_name: (optional) User first name
            last_name: (optional) User last name
            groups: (optional) The groups to add the user to
            preferences: (optional) User preferences
            ui_settings: (optional) User ui settings

        Returns:
             Newly created user object
        &#34;&#34;&#34;
        user_obj = {
            &#39;email&#39;: email,
            &#39;username&#39;: user_name if user_name is not None else email,
            &#39;roleId&#39;: self.get_role_id(role)
        }

        group_ids = []
        for group in PySenseUtils.make_iterable(groups):
            group_ids.append(group.get_id())
        if len(group_ids) &gt; 0:
            user_obj[&#39;groups&#39;] = group_ids

        if first_name is not None:
            user_obj[&#39;firstName&#39;] = first_name
        if last_name is not None:
            user_obj[&#39;lastName&#39;] = last_name
        if preferences is not None:
            user_obj[&#39;preferences&#39;] = preferences
        if ui_settings is not None:
            user_obj[&#39;uiSettings&#39;] = ui_settings

        resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/users&#39;, json_payload=user_obj)
        return PySenseUser.User(self, resp_json)

    def get_users(self, *, user_name=None, email=None, first_name=None, last_name=None, role_name=None, group=None,
                  active=None, origin=None, ids=None, fields=[], sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;Returns a list of users.

        Results can be filtered by parameters such as username and email.
        The expandable fields for the user object are groups, adgroups and role.

        Args:
            user_name: (optional) Username to filter by
            email: (optional) Email to filter by
            first_name: (optional) First name to filter by
            last_name: (optional) Last name to filter by
            role_name: (optional) Role filter by
            group: (optional) Group to filter by
            active: (optional) User state to filter by (true for active users, false for inactive users)
            origin: (optional) User origin to filter by (ad for active directory or sisense)
            ids: (optional) Array of user ids to get
            fields: (optional) An array of fields to return for each document.
                Fields can also define which fields to exclude by prefixing field names with -
            sort: (optional) Field by which the results should be sorted.
                Ascending by default, descending if prefixed by -
            skip: (optional) Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging
            limit: (optional) How many results should be returned.
                limit is to be used with the skip parameter for paging
            expand: (optional) List of fields that should be expanded (substitutes their IDs with actual objects).
                May be nested using the resource.subResource format

        Returns:
             An array of PySenseUser.User objects
        &#34;&#34;&#34;

        fields = PySenseUtils.make_iterable(fields)
        fields.extend(
            [&#39;_id&#39;, &#39;lastLogin&#39;, &#39;groups&#39;, &#39;email&#39;, &#39;userName&#39;, &#39;firstName&#39;, &#39;lastName&#39;, &#39;roleId&#39;, &#39;preferences&#39;]
        )
        fields = list(dict.fromkeys(fields))
        query_params = {
            &#39;userName&#39;: user_name,
            &#39;email&#39;: email,
            &#39;firstName&#39;: first_name,
            &#39;lastName&#39;: last_name,
            &#39;role&#39;: self.get_role_id(role_name),
            &#39;group&#39;: group,
            &#39;active&#39;: active,
            &#39;origin&#39;: origin,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        ret_arr = []
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
        for user in resp_json:
            ret_arr.append((PySenseUser.User(self, user)))
        return ret_arr

    def get_user_by_email(self, email):
        &#34;&#34;&#34;Returns a single user based on email&#34;&#34;&#34;
        users = self.get_users(email=email)
        if len(users) == 0:
            None
        elif len(users) &gt; 1:
            raise PySenseException.PySenseException(&#39;{} users with email {} found. &#39;.format(len(users), email))
        else:
            return users[0]

    def get_user_by_id(self, user_id):
        &#34;&#34;&#34;Returns a single user based on id&#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users/{}&#39;.format(user_id))
        return PySenseUser.User(self, resp_json)

    def delete_users(self, users):
        &#34;&#34;&#34;Deletes the specified user or users

        Args:
            users: One to many users to delete
        &#34;&#34;&#34;
        for user in PySenseUtils.make_iterable(users):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/users/{}&#39;.format(user.get_id()))

    ############################################
    # Elasticubes                              #
    ############################################

    def get_elasticubes(self):
        &#34;&#34;&#34;Gets elasticubes&#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/elasticubes/getElasticubes&#39;)
        ret_arr = []
        for cube in resp_json:
            ret_arr.append(PySenseElasticube.Elasticube(self, cube))
        return ret_arr

    def get_elasticube_by_name(self, name):
        &#34;&#34;&#34;Gets elasticube with given name&#34;&#34;&#34;
        cubes = self.get_elasticubes()
        for cube in cubes:
            if cube.get_name() == name:
                return cube
        return None

    ############################################
    # Plug Ins                                 #
    ############################################

    def get_plugins(self, *, order_by=None, desc=None, search=None, skip=None, limit=None):
        &#34;&#34;&#34;Get all plugins installed.

        Args:
            order_by: (optional) Filter by provided field
            desc: (optional) Order by descending/ascending (boolean)
            search: (optional) Filter according to provided string
            skip: (optional) Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging.
            limit: (optional) How many results should be returned. limit is to be used with the skip parameter for paging

        Returns:
            An array of plugins
        &#34;&#34;&#34;
        query_params = {
            &#39;orderby&#39;: order_by,
            &#39;desc&#39;: desc,
            &#39;search&#39;: search,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        }
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/plugins&#39;, query_params=query_params)
        ret_arr = []
        for plugin in resp_json[&#39;plugins&#39;]:
            ret_arr.append((PySensePlugin.Plugin(self, plugin)))
        return ret_arr

    ############################################
    # Roles                                    #
    ############################################

    def get_role_id(self, role_name):
        &#34;&#34;&#34;Get the role id for the given role name&#34;&#34;&#34;
        if role_name is None:
            return None
        for item in self._roles:
            if role_name == item[&#39;name&#39;] or role_name == item[&#39;displayName&#39;]:
                return item[&#39;_id&#39;]
        raise PySenseException.PySenseException(&#39;No role with name {} found&#39;.format(role_name))

    def get_role_name(self, role_id):
        &#34;&#34;&#34;Get the role name for the given role id&#34;&#34;&#34;

        for item in self._roles:
            if role_id == item[&#39;_id&#39;]:
                return item[&#39;displayName&#39;]
        raise PySenseException.PySenseException(&#39;No role with id {} found&#39;.format(role_id))

    ############################################
    # Connections                              #
    ############################################

    def get_connections(self, *, provider=None, sort=None, skip=None, limit=None):
        &#34;&#34;&#34;Returns all the connections

        Args:
            provider: Type or list of types to filter for
            sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
            skip: Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging
            limit: How many results should be returned. limit is to be used with the skip parameter for paging
        &#34;&#34;&#34;
        query_params = {
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        }
        provider = PySenseUtils.make_iterable(provider)
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/connection&#39;, query_params=query_params)
        ret_arr = []
        for connection in resp_json:
            connection = PySenseConnection.make_connection(self, connection)
            if len(provider) &gt; 0:
                if connection.get_provider() in provider:
                    ret_arr.append(connection)
            else:
                ret_arr.append(connection)

        return ret_arr

    def get_connection_by_id(self, connection_id):
        &#34;&#34;&#34;Returns the connection with the given id&#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/connection/{}&#39;.format(connection_id))
        return PySenseConnection.make_connection(self, resp_json)

    def add_connection(self, connection_json):
        &#34;&#34;&#34;Add a new connection with given connection json&#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/connection&#39;, json_payload=connection_json)
        return PySenseConnection.make_connection(self, resp_json)

    def delete_connections(self, connections):
        &#34;&#34;&#34;Deletes the given PySense connections&#34;&#34;&#34;
        for connection in PySenseUtils.make_iterable(connections):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/connection/{}&#39;.format(connection.get_id()))

    ############################################
    # Data Models                              #
    ############################################

    def add_data_model(self, data_model, *, title=None, target_data_model=None):
        &#34;&#34;&#34;Adds a new data model to the instance.

        Sisense does not support this in Windows

        Can be used to update an existing data model by adding it to target data model.

        To add a new model with a new title
        add_data_model(model_to_add, title=&#39;New Title&#39;)

        To update an existing model
        add_data_model(new_data_model, target_data_model=old_data_model)

        If updating an existing data model, no modifications to title will happen.

        Args:
            data_model: The PySense DataModel object to import
            title: (optional) Title to give the data model
            target_data_model: (optional) The data model to update.
        &#34;&#34;&#34;
        if self.version == SisenseVersion.Version.WINDOWS:
            raise PySenseException.PySenseException(&#34;Import data model not supported on windows&#34;)

        target_data_model_id = target_data_model.get_oid() if target_data_model is not None else None

        query_params = {&#39;title&#39;: title, &#39;datamodelId&#39;: target_data_model_id}
        data_model_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v2/datamodel-imports/schema&#39;,
                                                   query_params=query_params, json_payload=data_model.get_schema_json())

        return PySenseDataModel.DataModel(self, data_model_json)

    def get_data_models(self, *, title=None, fields=None, sort=None, limit=None, skip=None):
        &#34;&#34;&#34;Gets data model schemas

        Sisense does not support this in Windows

        If fields is specified, PySense may experience issues.

        To get all data models:
        get_data_models()

        To get a data model called PySense:
        get_data_models(title=&#39;PySense&#39;)

        Args:
            title: (optional) Datamodel Title to search for
            fields: (optional) A whitelist of fields to return for each object in the response.
            sort: (optional) A field by which the results should be sorted.
                Results will be sorted in ascending order by default, or descending if the field name is prefixed by -.
            limit: (optional) Number of results to be returned from the data set.
                This field must be used with the skip parameter, and is intended for paging.
            skip: (optional) Number of results to skip from the start of the data set.
                This parameter must be used with the limit parameter, and is intended for paging.

        Returns:
            If title is specified, a single data model will be returned if a matching data model is found.
            Otherwise PySense will throw an exception.
            If title is not specified an array will be returned.

        &#34;&#34;&#34;
        if self.version == SisenseVersion.Version.WINDOWS:
            raise PySenseException.PySenseException(&#34;Get data model not supported on windows&#34;)

        query_params = {
            &#39;title&#39;: title,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;limit&#39;: limit,
            &#39;skip&#39;: skip
        }

        data_models = self.connector.rest_call(&#39;get&#39;, &#39;api/v2/datamodels/schema&#39;, query_params=query_params)
        if title is not None:
            if data_models is not None:
                return PySenseDataModel.DataModel(self, data_models)
            else:
                raise PySenseException.PySenseException(&#39;No data model with name {} found&#39;.format(title))
        else:
            ret_arr = []
            for data_model in data_models:
                ret_arr.append(PySenseDataModel.DataModel(self, data_model))
            return ret_arr

    def delete_data_model(self, data_models):
        &#34;&#34;&#34;Deletes the given data models

        Args:
            data_models: One to many data models to delete
        &#34;&#34;&#34;
        if self.version == SisenseVersion.Version.WINDOWS:
            raise PySenseException.PySenseException(&#34;Delete data model not supported on windows&#34;)

        for data_model in PySenseUtils.make_iterable(data_models):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v2/datamodels/{}&#39;.format(data_model.get_oid()))

    def get_branding(self):
        &#34;&#34;&#34;Returns the current branding&#34;&#34;&#34;
        return PySenseBranding.Branding(self.connector, self.connector.rest_call(&#39;get&#39;, &#39;api/branding&#39;))

    def set_branding(self, branding):
        &#34;&#34;&#34;Update the branding
        Args:
            - branding: The PySense Branding object
        &#34;&#34;&#34;
        self.connector.rest_call(&#39;post&#39;, &#39;api/branding&#39;, json_payload=branding.get_json())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PySense.PySense.authenticate_by_file"><code class="name flex">
<span>def <span class="ident">authenticate_by_file</span></span>(<span>config_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new PySense client with the credentials in the given config file.</p>
<p>py_client = PySense.authenticate_by_file('C:\PySense\PySenseConfig.yaml')</p>
<p>See sample config in Snippets/SampleConfig.yaml</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_file</code></strong></dt>
<dd>Yaml file with credentials</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new PySense client for the given credentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate_by_file(config_file):
    &#34;&#34;&#34;Creates a new PySense client with the credentials in the given config file.

    py_client = PySense.authenticate_by_file(&#39;C:\\PySense\\PySenseConfig.yaml&#39;)

    See sample config in Snippets/SampleConfig.yaml

    Args:
        config_file: Yaml file with credentials

    Returns:
        A new PySense client for the given credentials
    &#34;&#34;&#34;
    return PySenseAuthentication.authenticate_by_file(config_file)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.authenticate_by_password"><code class="name flex">
<span>def <span class="ident">authenticate_by_password</span></span>(<span>host, username, password, version, debug=False, verify=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new PySense client with the username and password</p>
<h2 id="args">Args</h2>
<ul>
<li>host: The Sisense server address</li>
<li>username: Sisense username</li>
<li>password: Sisense password</li>
<li>version: 'Windows' or 'Linux'</li>
<li>debug: (Optional) True to enable debugging. False by default.</li>
<li>verify: (Optional) False to disable SSL certificate verification. True by default.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>A new PySense client for the given credentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate_by_password(host, username, password, version, debug=False, verify=True):
    &#34;&#34;&#34;Creates a new PySense client with the username and password

    Args:
        - host: The Sisense server address
        - username: Sisense username
        - password: Sisense password
        - version: &#39;Windows&#39; or &#39;Linux&#39;
        - debug: (Optional) True to enable debugging. False by default.
        - verify: (Optional) False to disable SSL certificate verification. True by default.


    Returns:
        A new PySense client for the given credentials
    &#34;&#34;&#34;
    return PySenseAuthentication.authenticate_by_password(host, username, password, version, debug, verify)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.authenticate_by_token"><code class="name flex">
<span>def <span class="ident">authenticate_by_token</span></span>(<span>host, token, version, debug=False, verify=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new PySense client with the token</p>
<h2 id="args">Args</h2>
<ul>
<li>host: The Sisense server address</li>
<li>token: A Sisense user token</li>
<li>version: 'Windows' or 'Linux'</li>
<li>debug: (Optional) True to enable debugging. False by default.</li>
<li>verify: (Optional) False to disable SSL certificate verification. True by default.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>A new PySense client for the given credentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate_by_token(host, token, version, debug=False, verify=True):
    &#34;&#34;&#34;Creates a new PySense client with the token

    Args:
        - host: The Sisense server address
        - token: A Sisense user token
        - version: &#39;Windows&#39; or &#39;Linux&#39;
        - debug: (Optional) True to enable debugging. False by default.
        - verify: (Optional) False to disable SSL certificate verification. True by default.


    Returns:
        A new PySense client for the given credentials
    &#34;&#34;&#34;
    return PySenseAuthentication.authenticate_by_token(host, token, version, debug, verify)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PySense.PySense.PySense"><code class="flex name class">
<span>class <span class="ident">PySense</span></span>
<span>(</span><span>host, token, version, *, debug=False, verify=True)</span>
</code></dt>
<dd>
<div class="desc"><p>The manager of connections to the PySense server</p>
<p>This class is for sever level changes like getting, adding, and removing dashboards, elasticubes, users, etc</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>connector</code></strong></dt>
<dd>The PySenseRestConnector which runs the rest commands.</dd>
</dl>
<p>Initializes a PySense instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host address</dd>
<dt><strong><code>token</code></strong></dt>
<dd _Bearer="&quot;Bearer" _authorization_:="'authorization':" yourlongaccesstokenstringthatyougotfromapreviouslogin_="yourlongaccesstokenstringthatyougotfromapreviouslogin&quot;">a json bearer token with format</dd>
<dt><strong><code>version</code></strong></dt>
<dd>version (either 'Windows' or 'Linux')</dd>
<dt><strong><code>debug</code></strong></dt>
<dd>If true, prints detailed REST API logs to console. False by default.</dd>
<dt><strong><code>verify</code></strong></dt>
<dd>If false, disables SSL Certification. True by default.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PySense:
    &#34;&#34;&#34;The manager of connections to the PySense server

    This class is for sever level changes like getting, adding, and removing dashboards, elasticubes, users, etc

    Attributes:
        connector: The PySenseRestConnector which runs the rest commands.
    &#34;&#34;&#34;

    def __init__(self, host, token, version, *, debug=False, verify=True):
        &#34;&#34;&#34; Initializes a PySense instance

        Args:
            host: host address
            token: a json bearer token with format
                {&#39;authorization&#39;:  &#34;Bearer yourlongaccesstokenstringthatyougotfromapreviouslogin&#34;}
            version: version (either &#39;Windows&#39; or &#39;Linux&#39;)
            debug: If true, prints detailed REST API logs to console. False by default.
            verify: If false, disables SSL Certification. True by default.
        &#34;&#34;&#34;
        if version.lower() == &#39;windows&#39;:
            self.version = SisenseVersion.Version.WINDOWS
        elif version.lower() == &#39;linux&#39;:
            self.version = SisenseVersion.Version.LINUX
        else:
            raise PySenseException.PySenseException(&#39;{} not a valid OS. Please select Linux or Windows&#39;.format(version))

        self.connector = PySenseRestConnector.RestConnector(host, token, debug, verify)
        self._roles = self.connector.rest_call(&#39;get&#39;, &#39;api/roles&#39;)

    def set_debug(self, debug):
        &#34;&#34;&#34;Enable or disable logging of REST api calls to std out.

        Use for debugging. Debug is false by default.
        &#34;&#34;&#34;
        self.connector.debug = debug

    ############################################
    # Dashboards                               #
    ############################################

    def get_dashboards(self, *, parent_folder=None, name=None, data_source_title=None,
                       data_source_address=None, fields=None, sort=None, expand=None):
        &#34;&#34;&#34;Get all dashboards.

        Args:
            parent_folder: Parent folder to filter by
            name: Name to filter by
            data_source_title: Data source name to filter by
            data_source_address: Data source address to filter by
            fields: Whitelist of fields to return for each document.
               Can also exclude by prefixing field names with -
            sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
            expand: List of fields that should be expanded

        Returns:
            An array of all found dashboards
        &#34;&#34;&#34;

        folder_id = None
        if parent_folder:
            folder_id = parent_folder.get_id()

        query_params = {
            &#39;parentFolder&#39;: folder_id,
            &#39;name&#39;: name,
            &#39;datasourceTitle&#39;: data_source_title,
            &#39;datasourceAddress&#39;: data_source_address,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;expand&#39;: expand
        }
        json_arr = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards&#39;, query_params=query_params)

        ret_arr = []
        for dash in json_arr:
            ret_arr.append(PySenseDashboard.Dashboard(self, dash))
        return ret_arr

    def get_dashboard_by_id(self, dashboard_id, *, fields=None, expand=None):
        &#34;&#34;&#34;Returns a specific dashboard object by ID.

        Args:
            dashboard_id: The ID of the dashboard to get
            fields: (optional) Whitelist of fields to return for each document.
                Fields Can also define which fields to exclude by prefixing field names with -
            expand: (optional) List of fields that should be expanded (substitues their IDs with actual objects).
                May be nested using the resource.subResource format

        Returns:
             Dashboard with the given id.
        &#34;&#34;&#34;

        query_params = {
            &#39;fields&#39;: fields,
            &#39;expand&#39;: expand
        }

        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id),
                                             query_params=query_params)

        return PySenseDashboard.Dashboard(self, resp_json)

    def add_dashboards(self, dashboards):
        &#34;&#34;&#34;Import given dashboards.

        Args:
            dashboards: One to many PySense dashboard to import

        Returns:
            An array of new dashboards
        &#34;&#34;&#34;
        ret_arr = []
        for dashboard in PySenseUtils.make_iterable(dashboards):
            resp = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/dashboards&#39;, json_payload=dashboard.get_json())
            ret_arr.append(PySenseDashboard.Dashboard(self, resp))
        return ret_arr

    def delete_dashboards(self, dashboards):
        &#34;&#34;&#34;Delete dashboards.

        Args:
            dashboards: Dashboards to delete
        &#34;&#34;&#34;
        for dashboard in PySenseUtils.make_iterable(dashboards):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard.get_id()))

    ############################################
    # Folders                                  #
    ############################################

    def get_folders(self, *, name=None, structure=None, ids=None, fields=None,
                    sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;Provides access to a specified user’s folders in their stored format.

        Args:
            name: (optional) Name to filter by
            structure: (optional) Structure type of the folders
            ids: (optional) Array of folder IDs to get, separated by a comma (,) and without spaces
            fields: (optional) Whitelist of fields to return for each document.
                Fields Can also define which fields to exclude by prefixing field names with -
            sort: (optional) Field by which the results should be sorted.
                Ascending by default, descending if prefixed by -
            skip: (optional) Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging
            limit: (optional) How many results should be returned.
                limit is to be used with the skip parameter for paging
            expand: (optional) List of fields that should be expanded (substitue their IDs with actual objects).
                May be nested using the resource.subResource format

        Returns:
             An array of folders matching the search criteria
        &#34;&#34;&#34;
        ret_arr = []
        query_params = {
            &#39;name&#39;: name,
            &#39;structure&#39;: structure,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }

        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders&#39;, query_params=query_params)

        # Sisense Rest API always returns the root folder, so we filter it out when looking by name
        if name:
            for folder in resp_json:
                if folder[&#39;name&#39;] == name:
                    ret_arr.append(PySenseFolder.Folder(self, folder))
        else:
            for folder in resp_json:
                ret_arr.append(PySenseFolder.Folder(self, folder))
        return ret_arr

    def get_folder_by_id(self, folder_id):
        &#34;&#34;&#34;Get a specific folder by folder id.&#34;&#34;&#34;
        if folder_id is None:
            return None
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders/{}&#39;.format(folder_id))
        return PySenseFolder.Folder(self, resp_json)

    ############################################
    # Groups                                   #
    ############################################

    def get_groups(self, *, name=None, mail=None, role=None, origin=None, ids=None, fields=None,
                   sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;Returns a list of user groups with their details.
        The results can be filtered by different parameters such as group name or origin.

        Args:
            name: (optional) Group name to filter by
            mail: (optional) Group email to filter by
            role: (optional) Group role to filter by
            origin: (optional) Group origin to filter by (ad or sisense)
            ids: (optional) Array of group IDs to filter by
            fields: (optional) Whitelist of fields to return for each document.
                Fields can also define which fields to exclude by prefixing field names with -
            sort: (optional) Field by which the results should be sorted.
                Ascending by default, descending if prefixed by -
            skip: (optional) Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging
            limit: (optional) How many results should be returned.
                limit is to be used with the skip parameter for paging
            expand: (optional) List of fields that should be expanded (substitures their IDs with actual objects).
                May be nested using the resource.subResource format

        Returns:
            Array of found groups
        &#34;&#34;&#34;

        query_params = {
            &#39;name&#39;: name,
            &#39;mail&#39;: mail,
            &#39;roleId&#39;: self.get_role_id(role),
            &#39;origin&#39;: origin,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;, query_params=query_params)

        ret_arr = []
        for group in resp_json:
            ret_arr.append(PySenseGroup.Group(self, group))
        return ret_arr

    def get_group_by_id(self, group_id):
        &#34;&#34;&#34;Get a group by id&#34;&#34;&#34;
        if group_id is None:
            return None
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/groups/{}&#39;.format(group_id))
        return PySenseGroup.Group(self, resp_json)

    def get_groups_by_name(self, group_names):
        &#34;&#34;&#34;Returns an array of groups matching the given names

        Args:
            group_names: One to many group names
        &#34;&#34;&#34;
        if group_names is None:
            return []

        server_groups = self.get_groups()
        ret = []
        group_names = PySenseUtils.make_iterable(group_names)
        for group in server_groups:
            if group.get_name() in group_names:
                ret.append(group)
        return ret

    def add_groups(self, names):
        &#34;&#34;&#34;Add groups with given names.

        Args:
            names: One to many names

        Returns:
            Array of new groups
        &#34;&#34;&#34;
        ret_arr = []
        for name in PySenseUtils.make_iterable(names):
            payload = {&#39;name&#39;: name}
            resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/groups&#39;, json_payload=payload)
            ret_arr.append(PySenseGroup.Group(self, resp_json))
        return ret_arr

    def delete_groups(self, groups):
        &#34;&#34;&#34;Delete groups.

        Args:
            groups: One to many groups to delete
        &#34;&#34;&#34;
        for group in PySenseUtils.make_iterable(groups):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/groups/{}&#39;.format(group.get_id()))

    ############################################
    # Users                                    #
    ############################################

    def add_user(self, email, role, *, user_name=None, first_name=None, last_name=None,
                 groups=[], preferences={}, ui_settings={}):
        &#34;&#34;&#34;Creates a user in Sisense.

        Args:
            email: email address for user
            role: role of user
            user_name: (optional) User user name. Email used if None
            first_name: (optional) User first name
            last_name: (optional) User last name
            groups: (optional) The groups to add the user to
            preferences: (optional) User preferences
            ui_settings: (optional) User ui settings

        Returns:
             Newly created user object
        &#34;&#34;&#34;
        user_obj = {
            &#39;email&#39;: email,
            &#39;username&#39;: user_name if user_name is not None else email,
            &#39;roleId&#39;: self.get_role_id(role)
        }

        group_ids = []
        for group in PySenseUtils.make_iterable(groups):
            group_ids.append(group.get_id())
        if len(group_ids) &gt; 0:
            user_obj[&#39;groups&#39;] = group_ids

        if first_name is not None:
            user_obj[&#39;firstName&#39;] = first_name
        if last_name is not None:
            user_obj[&#39;lastName&#39;] = last_name
        if preferences is not None:
            user_obj[&#39;preferences&#39;] = preferences
        if ui_settings is not None:
            user_obj[&#39;uiSettings&#39;] = ui_settings

        resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/users&#39;, json_payload=user_obj)
        return PySenseUser.User(self, resp_json)

    def get_users(self, *, user_name=None, email=None, first_name=None, last_name=None, role_name=None, group=None,
                  active=None, origin=None, ids=None, fields=[], sort=None, skip=None, limit=None, expand=None):
        &#34;&#34;&#34;Returns a list of users.

        Results can be filtered by parameters such as username and email.
        The expandable fields for the user object are groups, adgroups and role.

        Args:
            user_name: (optional) Username to filter by
            email: (optional) Email to filter by
            first_name: (optional) First name to filter by
            last_name: (optional) Last name to filter by
            role_name: (optional) Role filter by
            group: (optional) Group to filter by
            active: (optional) User state to filter by (true for active users, false for inactive users)
            origin: (optional) User origin to filter by (ad for active directory or sisense)
            ids: (optional) Array of user ids to get
            fields: (optional) An array of fields to return for each document.
                Fields can also define which fields to exclude by prefixing field names with -
            sort: (optional) Field by which the results should be sorted.
                Ascending by default, descending if prefixed by -
            skip: (optional) Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging
            limit: (optional) How many results should be returned.
                limit is to be used with the skip parameter for paging
            expand: (optional) List of fields that should be expanded (substitutes their IDs with actual objects).
                May be nested using the resource.subResource format

        Returns:
             An array of PySenseUser.User objects
        &#34;&#34;&#34;

        fields = PySenseUtils.make_iterable(fields)
        fields.extend(
            [&#39;_id&#39;, &#39;lastLogin&#39;, &#39;groups&#39;, &#39;email&#39;, &#39;userName&#39;, &#39;firstName&#39;, &#39;lastName&#39;, &#39;roleId&#39;, &#39;preferences&#39;]
        )
        fields = list(dict.fromkeys(fields))
        query_params = {
            &#39;userName&#39;: user_name,
            &#39;email&#39;: email,
            &#39;firstName&#39;: first_name,
            &#39;lastName&#39;: last_name,
            &#39;role&#39;: self.get_role_id(role_name),
            &#39;group&#39;: group,
            &#39;active&#39;: active,
            &#39;origin&#39;: origin,
            &#39;ids&#39;: ids,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit,
            &#39;expand&#39;: expand
        }
        ret_arr = []
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
        for user in resp_json:
            ret_arr.append((PySenseUser.User(self, user)))
        return ret_arr

    def get_user_by_email(self, email):
        &#34;&#34;&#34;Returns a single user based on email&#34;&#34;&#34;
        users = self.get_users(email=email)
        if len(users) == 0:
            None
        elif len(users) &gt; 1:
            raise PySenseException.PySenseException(&#39;{} users with email {} found. &#39;.format(len(users), email))
        else:
            return users[0]

    def get_user_by_id(self, user_id):
        &#34;&#34;&#34;Returns a single user based on id&#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users/{}&#39;.format(user_id))
        return PySenseUser.User(self, resp_json)

    def delete_users(self, users):
        &#34;&#34;&#34;Deletes the specified user or users

        Args:
            users: One to many users to delete
        &#34;&#34;&#34;
        for user in PySenseUtils.make_iterable(users):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/users/{}&#39;.format(user.get_id()))

    ############################################
    # Elasticubes                              #
    ############################################

    def get_elasticubes(self):
        &#34;&#34;&#34;Gets elasticubes&#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/elasticubes/getElasticubes&#39;)
        ret_arr = []
        for cube in resp_json:
            ret_arr.append(PySenseElasticube.Elasticube(self, cube))
        return ret_arr

    def get_elasticube_by_name(self, name):
        &#34;&#34;&#34;Gets elasticube with given name&#34;&#34;&#34;
        cubes = self.get_elasticubes()
        for cube in cubes:
            if cube.get_name() == name:
                return cube
        return None

    ############################################
    # Plug Ins                                 #
    ############################################

    def get_plugins(self, *, order_by=None, desc=None, search=None, skip=None, limit=None):
        &#34;&#34;&#34;Get all plugins installed.

        Args:
            order_by: (optional) Filter by provided field
            desc: (optional) Order by descending/ascending (boolean)
            search: (optional) Filter according to provided string
            skip: (optional) Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging.
            limit: (optional) How many results should be returned. limit is to be used with the skip parameter for paging

        Returns:
            An array of plugins
        &#34;&#34;&#34;
        query_params = {
            &#39;orderby&#39;: order_by,
            &#39;desc&#39;: desc,
            &#39;search&#39;: search,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        }
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/plugins&#39;, query_params=query_params)
        ret_arr = []
        for plugin in resp_json[&#39;plugins&#39;]:
            ret_arr.append((PySensePlugin.Plugin(self, plugin)))
        return ret_arr

    ############################################
    # Roles                                    #
    ############################################

    def get_role_id(self, role_name):
        &#34;&#34;&#34;Get the role id for the given role name&#34;&#34;&#34;
        if role_name is None:
            return None
        for item in self._roles:
            if role_name == item[&#39;name&#39;] or role_name == item[&#39;displayName&#39;]:
                return item[&#39;_id&#39;]
        raise PySenseException.PySenseException(&#39;No role with name {} found&#39;.format(role_name))

    def get_role_name(self, role_id):
        &#34;&#34;&#34;Get the role name for the given role id&#34;&#34;&#34;

        for item in self._roles:
            if role_id == item[&#39;_id&#39;]:
                return item[&#39;displayName&#39;]
        raise PySenseException.PySenseException(&#39;No role with id {} found&#39;.format(role_id))

    ############################################
    # Connections                              #
    ############################################

    def get_connections(self, *, provider=None, sort=None, skip=None, limit=None):
        &#34;&#34;&#34;Returns all the connections

        Args:
            provider: Type or list of types to filter for
            sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
            skip: Number of results to skip from the start of the data set.
                Skip is to be used with the limit parameter for paging
            limit: How many results should be returned. limit is to be used with the skip parameter for paging
        &#34;&#34;&#34;
        query_params = {
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        }
        provider = PySenseUtils.make_iterable(provider)
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/connection&#39;, query_params=query_params)
        ret_arr = []
        for connection in resp_json:
            connection = PySenseConnection.make_connection(self, connection)
            if len(provider) &gt; 0:
                if connection.get_provider() in provider:
                    ret_arr.append(connection)
            else:
                ret_arr.append(connection)

        return ret_arr

    def get_connection_by_id(self, connection_id):
        &#34;&#34;&#34;Returns the connection with the given id&#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/connection/{}&#39;.format(connection_id))
        return PySenseConnection.make_connection(self, resp_json)

    def add_connection(self, connection_json):
        &#34;&#34;&#34;Add a new connection with given connection json&#34;&#34;&#34;
        resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/connection&#39;, json_payload=connection_json)
        return PySenseConnection.make_connection(self, resp_json)

    def delete_connections(self, connections):
        &#34;&#34;&#34;Deletes the given PySense connections&#34;&#34;&#34;
        for connection in PySenseUtils.make_iterable(connections):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/connection/{}&#39;.format(connection.get_id()))

    ############################################
    # Data Models                              #
    ############################################

    def add_data_model(self, data_model, *, title=None, target_data_model=None):
        &#34;&#34;&#34;Adds a new data model to the instance.

        Sisense does not support this in Windows

        Can be used to update an existing data model by adding it to target data model.

        To add a new model with a new title
        add_data_model(model_to_add, title=&#39;New Title&#39;)

        To update an existing model
        add_data_model(new_data_model, target_data_model=old_data_model)

        If updating an existing data model, no modifications to title will happen.

        Args:
            data_model: The PySense DataModel object to import
            title: (optional) Title to give the data model
            target_data_model: (optional) The data model to update.
        &#34;&#34;&#34;
        if self.version == SisenseVersion.Version.WINDOWS:
            raise PySenseException.PySenseException(&#34;Import data model not supported on windows&#34;)

        target_data_model_id = target_data_model.get_oid() if target_data_model is not None else None

        query_params = {&#39;title&#39;: title, &#39;datamodelId&#39;: target_data_model_id}
        data_model_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v2/datamodel-imports/schema&#39;,
                                                   query_params=query_params, json_payload=data_model.get_schema_json())

        return PySenseDataModel.DataModel(self, data_model_json)

    def get_data_models(self, *, title=None, fields=None, sort=None, limit=None, skip=None):
        &#34;&#34;&#34;Gets data model schemas

        Sisense does not support this in Windows

        If fields is specified, PySense may experience issues.

        To get all data models:
        get_data_models()

        To get a data model called PySense:
        get_data_models(title=&#39;PySense&#39;)

        Args:
            title: (optional) Datamodel Title to search for
            fields: (optional) A whitelist of fields to return for each object in the response.
            sort: (optional) A field by which the results should be sorted.
                Results will be sorted in ascending order by default, or descending if the field name is prefixed by -.
            limit: (optional) Number of results to be returned from the data set.
                This field must be used with the skip parameter, and is intended for paging.
            skip: (optional) Number of results to skip from the start of the data set.
                This parameter must be used with the limit parameter, and is intended for paging.

        Returns:
            If title is specified, a single data model will be returned if a matching data model is found.
            Otherwise PySense will throw an exception.
            If title is not specified an array will be returned.

        &#34;&#34;&#34;
        if self.version == SisenseVersion.Version.WINDOWS:
            raise PySenseException.PySenseException(&#34;Get data model not supported on windows&#34;)

        query_params = {
            &#39;title&#39;: title,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;limit&#39;: limit,
            &#39;skip&#39;: skip
        }

        data_models = self.connector.rest_call(&#39;get&#39;, &#39;api/v2/datamodels/schema&#39;, query_params=query_params)
        if title is not None:
            if data_models is not None:
                return PySenseDataModel.DataModel(self, data_models)
            else:
                raise PySenseException.PySenseException(&#39;No data model with name {} found&#39;.format(title))
        else:
            ret_arr = []
            for data_model in data_models:
                ret_arr.append(PySenseDataModel.DataModel(self, data_model))
            return ret_arr

    def delete_data_model(self, data_models):
        &#34;&#34;&#34;Deletes the given data models

        Args:
            data_models: One to many data models to delete
        &#34;&#34;&#34;
        if self.version == SisenseVersion.Version.WINDOWS:
            raise PySenseException.PySenseException(&#34;Delete data model not supported on windows&#34;)

        for data_model in PySenseUtils.make_iterable(data_models):
            self.connector.rest_call(&#39;delete&#39;, &#39;api/v2/datamodels/{}&#39;.format(data_model.get_oid()))

    def get_branding(self):
        &#34;&#34;&#34;Returns the current branding&#34;&#34;&#34;
        return PySenseBranding.Branding(self.connector, self.connector.rest_call(&#39;get&#39;, &#39;api/branding&#39;))

    def set_branding(self, branding):
        &#34;&#34;&#34;Update the branding
        Args:
            - branding: The PySense Branding object
        &#34;&#34;&#34;
        self.connector.rest_call(&#39;post&#39;, &#39;api/branding&#39;, json_payload=branding.get_json())</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PySense.PySense.PySense.add_connection"><code class="name flex">
<span>def <span class="ident">add_connection</span></span>(<span>self, connection_json)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new connection with given connection json</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_connection(self, connection_json):
    &#34;&#34;&#34;Add a new connection with given connection json&#34;&#34;&#34;
    resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/connection&#39;, json_payload=connection_json)
    return PySenseConnection.make_connection(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.add_dashboards"><code class="name flex">
<span>def <span class="ident">add_dashboards</span></span>(<span>self, dashboards)</span>
</code></dt>
<dd>
<div class="desc"><p>Import given dashboards.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dashboards</code></strong></dt>
<dd>One to many PySense dashboard to import</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An array of new dashboards</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dashboards(self, dashboards):
    &#34;&#34;&#34;Import given dashboards.

    Args:
        dashboards: One to many PySense dashboard to import

    Returns:
        An array of new dashboards
    &#34;&#34;&#34;
    ret_arr = []
    for dashboard in PySenseUtils.make_iterable(dashboards):
        resp = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/dashboards&#39;, json_payload=dashboard.get_json())
        ret_arr.append(PySenseDashboard.Dashboard(self, resp))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.add_data_model"><code class="name flex">
<span>def <span class="ident">add_data_model</span></span>(<span>self, data_model, *, title=None, target_data_model=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new data model to the instance.</p>
<p>Sisense does not support this in Windows</p>
<p>Can be used to update an existing data model by adding it to target data model.</p>
<p>To add a new model with a new title
add_data_model(model_to_add, title='New Title')</p>
<p>To update an existing model
add_data_model(new_data_model, target_data_model=old_data_model)</p>
<p>If updating an existing data model, no modifications to title will happen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_model</code></strong></dt>
<dd>The PySense DataModel object to import</dd>
<dt><strong><code>title</code></strong></dt>
<dd>(optional) Title to give the data model</dd>
<dt><strong><code>target_data_model</code></strong></dt>
<dd>(optional) The data model to update.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_data_model(self, data_model, *, title=None, target_data_model=None):
    &#34;&#34;&#34;Adds a new data model to the instance.

    Sisense does not support this in Windows

    Can be used to update an existing data model by adding it to target data model.

    To add a new model with a new title
    add_data_model(model_to_add, title=&#39;New Title&#39;)

    To update an existing model
    add_data_model(new_data_model, target_data_model=old_data_model)

    If updating an existing data model, no modifications to title will happen.

    Args:
        data_model: The PySense DataModel object to import
        title: (optional) Title to give the data model
        target_data_model: (optional) The data model to update.
    &#34;&#34;&#34;
    if self.version == SisenseVersion.Version.WINDOWS:
        raise PySenseException.PySenseException(&#34;Import data model not supported on windows&#34;)

    target_data_model_id = target_data_model.get_oid() if target_data_model is not None else None

    query_params = {&#39;title&#39;: title, &#39;datamodelId&#39;: target_data_model_id}
    data_model_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v2/datamodel-imports/schema&#39;,
                                               query_params=query_params, json_payload=data_model.get_schema_json())

    return PySenseDataModel.DataModel(self, data_model_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.add_groups"><code class="name flex">
<span>def <span class="ident">add_groups</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>Add groups with given names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>names</code></strong></dt>
<dd>One to many names</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Array of new groups</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_groups(self, names):
    &#34;&#34;&#34;Add groups with given names.

    Args:
        names: One to many names

    Returns:
        Array of new groups
    &#34;&#34;&#34;
    ret_arr = []
    for name in PySenseUtils.make_iterable(names):
        payload = {&#39;name&#39;: name}
        resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/groups&#39;, json_payload=payload)
        ret_arr.append(PySenseGroup.Group(self, resp_json))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.add_user"><code class="name flex">
<span>def <span class="ident">add_user</span></span>(<span>self, email, role, *, user_name=None, first_name=None, last_name=None, groups=[], preferences={}, ui_settings={})</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a user in Sisense.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>email</code></strong></dt>
<dd>email address for user</dd>
<dt><strong><code>role</code></strong></dt>
<dd>role of user</dd>
<dt><strong><code>user_name</code></strong></dt>
<dd>(optional) User user name. Email used if None</dd>
<dt><strong><code>first_name</code></strong></dt>
<dd>(optional) User first name</dd>
<dt><strong><code>last_name</code></strong></dt>
<dd>(optional) User last name</dd>
<dt><strong><code>groups</code></strong></dt>
<dd>(optional) The groups to add the user to</dd>
<dt><strong><code>preferences</code></strong></dt>
<dd>(optional) User preferences</dd>
<dt><strong><code>ui_settings</code></strong></dt>
<dd>(optional) User ui settings</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Newly created user object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_user(self, email, role, *, user_name=None, first_name=None, last_name=None,
             groups=[], preferences={}, ui_settings={}):
    &#34;&#34;&#34;Creates a user in Sisense.

    Args:
        email: email address for user
        role: role of user
        user_name: (optional) User user name. Email used if None
        first_name: (optional) User first name
        last_name: (optional) User last name
        groups: (optional) The groups to add the user to
        preferences: (optional) User preferences
        ui_settings: (optional) User ui settings

    Returns:
         Newly created user object
    &#34;&#34;&#34;
    user_obj = {
        &#39;email&#39;: email,
        &#39;username&#39;: user_name if user_name is not None else email,
        &#39;roleId&#39;: self.get_role_id(role)
    }

    group_ids = []
    for group in PySenseUtils.make_iterable(groups):
        group_ids.append(group.get_id())
    if len(group_ids) &gt; 0:
        user_obj[&#39;groups&#39;] = group_ids

    if first_name is not None:
        user_obj[&#39;firstName&#39;] = first_name
    if last_name is not None:
        user_obj[&#39;lastName&#39;] = last_name
    if preferences is not None:
        user_obj[&#39;preferences&#39;] = preferences
    if ui_settings is not None:
        user_obj[&#39;uiSettings&#39;] = ui_settings

    resp_json = self.connector.rest_call(&#39;post&#39;, &#39;api/v1/users&#39;, json_payload=user_obj)
    return PySenseUser.User(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.delete_connections"><code class="name flex">
<span>def <span class="ident">delete_connections</span></span>(<span>self, connections)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the given PySense connections</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_connections(self, connections):
    &#34;&#34;&#34;Deletes the given PySense connections&#34;&#34;&#34;
    for connection in PySenseUtils.make_iterable(connections):
        self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/connection/{}&#39;.format(connection.get_id()))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.delete_dashboards"><code class="name flex">
<span>def <span class="ident">delete_dashboards</span></span>(<span>self, dashboards)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete dashboards.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dashboards</code></strong></dt>
<dd>Dashboards to delete</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_dashboards(self, dashboards):
    &#34;&#34;&#34;Delete dashboards.

    Args:
        dashboards: Dashboards to delete
    &#34;&#34;&#34;
    for dashboard in PySenseUtils.make_iterable(dashboards):
        self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard.get_id()))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.delete_data_model"><code class="name flex">
<span>def <span class="ident">delete_data_model</span></span>(<span>self, data_models)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the given data models</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_models</code></strong></dt>
<dd>One to many data models to delete</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_data_model(self, data_models):
    &#34;&#34;&#34;Deletes the given data models

    Args:
        data_models: One to many data models to delete
    &#34;&#34;&#34;
    if self.version == SisenseVersion.Version.WINDOWS:
        raise PySenseException.PySenseException(&#34;Delete data model not supported on windows&#34;)

    for data_model in PySenseUtils.make_iterable(data_models):
        self.connector.rest_call(&#39;delete&#39;, &#39;api/v2/datamodels/{}&#39;.format(data_model.get_oid()))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.delete_groups"><code class="name flex">
<span>def <span class="ident">delete_groups</span></span>(<span>self, groups)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete groups.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>groups</code></strong></dt>
<dd>One to many groups to delete</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_groups(self, groups):
    &#34;&#34;&#34;Delete groups.

    Args:
        groups: One to many groups to delete
    &#34;&#34;&#34;
    for group in PySenseUtils.make_iterable(groups):
        self.connector.rest_call(&#39;delete&#39;, &#39;api/groups/{}&#39;.format(group.get_id()))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.delete_users"><code class="name flex">
<span>def <span class="ident">delete_users</span></span>(<span>self, users)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the specified user or users</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>users</code></strong></dt>
<dd>One to many users to delete</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_users(self, users):
    &#34;&#34;&#34;Deletes the specified user or users

    Args:
        users: One to many users to delete
    &#34;&#34;&#34;
    for user in PySenseUtils.make_iterable(users):
        self.connector.rest_call(&#39;delete&#39;, &#39;api/v1/users/{}&#39;.format(user.get_id()))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_branding"><code class="name flex">
<span>def <span class="ident">get_branding</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current branding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_branding(self):
    &#34;&#34;&#34;Returns the current branding&#34;&#34;&#34;
    return PySenseBranding.Branding(self.connector, self.connector.rest_call(&#39;get&#39;, &#39;api/branding&#39;))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_connection_by_id"><code class="name flex">
<span>def <span class="ident">get_connection_by_id</span></span>(<span>self, connection_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the connection with the given id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_connection_by_id(self, connection_id):
    &#34;&#34;&#34;Returns the connection with the given id&#34;&#34;&#34;
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/connection/{}&#39;.format(connection_id))
    return PySenseConnection.make_connection(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_connections"><code class="name flex">
<span>def <span class="ident">get_connections</span></span>(<span>self, *, provider=None, sort=None, skip=None, limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all the connections</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>provider</code></strong></dt>
<dd>Type or list of types to filter for</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>Field by which the results should be sorted. Ascending by default, descending if prefixed by -</dd>
<dt><strong><code>skip</code></strong></dt>
<dd>Number of results to skip from the start of the data set.
Skip is to be used with the limit parameter for paging</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>How many results should be returned. limit is to be used with the skip parameter for paging</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_connections(self, *, provider=None, sort=None, skip=None, limit=None):
    &#34;&#34;&#34;Returns all the connections

    Args:
        provider: Type or list of types to filter for
        sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
        skip: Number of results to skip from the start of the data set.
            Skip is to be used with the limit parameter for paging
        limit: How many results should be returned. limit is to be used with the skip parameter for paging
    &#34;&#34;&#34;
    query_params = {
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit
    }
    provider = PySenseUtils.make_iterable(provider)
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/connection&#39;, query_params=query_params)
    ret_arr = []
    for connection in resp_json:
        connection = PySenseConnection.make_connection(self, connection)
        if len(provider) &gt; 0:
            if connection.get_provider() in provider:
                ret_arr.append(connection)
        else:
            ret_arr.append(connection)

    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_dashboard_by_id"><code class="name flex">
<span>def <span class="ident">get_dashboard_by_id</span></span>(<span>self, dashboard_id, *, fields=None, expand=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a specific dashboard object by ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dashboard_id</code></strong></dt>
<dd>The ID of the dashboard to get</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>(optional) Whitelist of fields to return for each document.
Fields Can also define which fields to exclude by prefixing field names with -</dd>
<dt><strong><code>expand</code></strong></dt>
<dd>(optional) List of fields that should be expanded (substitues their IDs with actual objects).
May be nested using the resource.subResource format</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dashboard with the given id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_by_id(self, dashboard_id, *, fields=None, expand=None):
    &#34;&#34;&#34;Returns a specific dashboard object by ID.

    Args:
        dashboard_id: The ID of the dashboard to get
        fields: (optional) Whitelist of fields to return for each document.
            Fields Can also define which fields to exclude by prefixing field names with -
        expand: (optional) List of fields that should be expanded (substitues their IDs with actual objects).
            May be nested using the resource.subResource format

    Returns:
         Dashboard with the given id.
    &#34;&#34;&#34;

    query_params = {
        &#39;fields&#39;: fields,
        &#39;expand&#39;: expand
    }

    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards/{}&#39;.format(dashboard_id),
                                         query_params=query_params)

    return PySenseDashboard.Dashboard(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_dashboards"><code class="name flex">
<span>def <span class="ident">get_dashboards</span></span>(<span>self, *, parent_folder=None, name=None, data_source_title=None, data_source_address=None, fields=None, sort=None, expand=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all dashboards.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_folder</code></strong></dt>
<dd>Parent folder to filter by</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name to filter by</dd>
<dt><strong><code>data_source_title</code></strong></dt>
<dd>Data source name to filter by</dd>
<dt><strong><code>data_source_address</code></strong></dt>
<dd>Data source address to filter by</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>Whitelist of fields to return for each document.
Can also exclude by prefixing field names with -</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>Field by which the results should be sorted. Ascending by default, descending if prefixed by -</dd>
<dt><strong><code>expand</code></strong></dt>
<dd>List of fields that should be expanded</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An array of all found dashboards</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboards(self, *, parent_folder=None, name=None, data_source_title=None,
                   data_source_address=None, fields=None, sort=None, expand=None):
    &#34;&#34;&#34;Get all dashboards.

    Args:
        parent_folder: Parent folder to filter by
        name: Name to filter by
        data_source_title: Data source name to filter by
        data_source_address: Data source address to filter by
        fields: Whitelist of fields to return for each document.
           Can also exclude by prefixing field names with -
        sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
        expand: List of fields that should be expanded

    Returns:
        An array of all found dashboards
    &#34;&#34;&#34;

    folder_id = None
    if parent_folder:
        folder_id = parent_folder.get_id()

    query_params = {
        &#39;parentFolder&#39;: folder_id,
        &#39;name&#39;: name,
        &#39;datasourceTitle&#39;: data_source_title,
        &#39;datasourceAddress&#39;: data_source_address,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;expand&#39;: expand
    }
    json_arr = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/dashboards&#39;, query_params=query_params)

    ret_arr = []
    for dash in json_arr:
        ret_arr.append(PySenseDashboard.Dashboard(self, dash))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_data_models"><code class="name flex">
<span>def <span class="ident">get_data_models</span></span>(<span>self, *, title=None, fields=None, sort=None, limit=None, skip=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets data model schemas</p>
<p>Sisense does not support this in Windows</p>
<p>If fields is specified, PySense may experience issues.</p>
<p>To get all data models:
get_data_models()</p>
<p>To get a data model called PySense:
get_data_models(title='PySense')</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong></dt>
<dd>(optional) Datamodel Title to search for</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>(optional) A whitelist of fields to return for each object in the response.</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>(optional) A field by which the results should be sorted.
Results will be sorted in ascending order by default, or descending if the field name is prefixed by -.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>(optional) Number of results to be returned from the data set.
This field must be used with the skip parameter, and is intended for paging.</dd>
<dt><strong><code>skip</code></strong></dt>
<dd>(optional) Number of results to skip from the start of the data set.
This parameter must be used with the limit parameter, and is intended for paging.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>If title is specified, a single data model will be returned if a matching data model is found.
Otherwise PySense will throw an exception.
If title is not specified an array will be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_models(self, *, title=None, fields=None, sort=None, limit=None, skip=None):
    &#34;&#34;&#34;Gets data model schemas

    Sisense does not support this in Windows

    If fields is specified, PySense may experience issues.

    To get all data models:
    get_data_models()

    To get a data model called PySense:
    get_data_models(title=&#39;PySense&#39;)

    Args:
        title: (optional) Datamodel Title to search for
        fields: (optional) A whitelist of fields to return for each object in the response.
        sort: (optional) A field by which the results should be sorted.
            Results will be sorted in ascending order by default, or descending if the field name is prefixed by -.
        limit: (optional) Number of results to be returned from the data set.
            This field must be used with the skip parameter, and is intended for paging.
        skip: (optional) Number of results to skip from the start of the data set.
            This parameter must be used with the limit parameter, and is intended for paging.

    Returns:
        If title is specified, a single data model will be returned if a matching data model is found.
        Otherwise PySense will throw an exception.
        If title is not specified an array will be returned.

    &#34;&#34;&#34;
    if self.version == SisenseVersion.Version.WINDOWS:
        raise PySenseException.PySenseException(&#34;Get data model not supported on windows&#34;)

    query_params = {
        &#39;title&#39;: title,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;limit&#39;: limit,
        &#39;skip&#39;: skip
    }

    data_models = self.connector.rest_call(&#39;get&#39;, &#39;api/v2/datamodels/schema&#39;, query_params=query_params)
    if title is not None:
        if data_models is not None:
            return PySenseDataModel.DataModel(self, data_models)
        else:
            raise PySenseException.PySenseException(&#39;No data model with name {} found&#39;.format(title))
    else:
        ret_arr = []
        for data_model in data_models:
            ret_arr.append(PySenseDataModel.DataModel(self, data_model))
        return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_elasticube_by_name"><code class="name flex">
<span>def <span class="ident">get_elasticube_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets elasticube with given name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elasticube_by_name(self, name):
    &#34;&#34;&#34;Gets elasticube with given name&#34;&#34;&#34;
    cubes = self.get_elasticubes()
    for cube in cubes:
        if cube.get_name() == name:
            return cube
    return None</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_elasticubes"><code class="name flex">
<span>def <span class="ident">get_elasticubes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets elasticubes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elasticubes(self):
    &#34;&#34;&#34;Gets elasticubes&#34;&#34;&#34;
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/elasticubes/getElasticubes&#39;)
    ret_arr = []
    for cube in resp_json:
        ret_arr.append(PySenseElasticube.Elasticube(self, cube))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_folder_by_id"><code class="name flex">
<span>def <span class="ident">get_folder_by_id</span></span>(<span>self, folder_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a specific folder by folder id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folder_by_id(self, folder_id):
    &#34;&#34;&#34;Get a specific folder by folder id.&#34;&#34;&#34;
    if folder_id is None:
        return None
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders/{}&#39;.format(folder_id))
    return PySenseFolder.Folder(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_folders"><code class="name flex">
<span>def <span class="ident">get_folders</span></span>(<span>self, *, name=None, structure=None, ids=None, fields=None, sort=None, skip=None, limit=None, expand=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides access to a specified user’s folders in their stored format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>(optional) Name to filter by</dd>
<dt><strong><code>structure</code></strong></dt>
<dd>(optional) Structure type of the folders</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>(optional) Array of folder IDs to get, separated by a comma (,) and without spaces</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>(optional) Whitelist of fields to return for each document.
Fields Can also define which fields to exclude by prefixing field names with -</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>(optional) Field by which the results should be sorted.
Ascending by default, descending if prefixed by -</dd>
<dt><strong><code>skip</code></strong></dt>
<dd>(optional) Number of results to skip from the start of the data set.
Skip is to be used with the limit parameter for paging</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>(optional) How many results should be returned.
limit is to be used with the skip parameter for paging</dd>
<dt><strong><code>expand</code></strong></dt>
<dd>(optional) List of fields that should be expanded (substitue their IDs with actual objects).
May be nested using the resource.subResource format</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An array of folders matching the search criteria</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folders(self, *, name=None, structure=None, ids=None, fields=None,
                sort=None, skip=None, limit=None, expand=None):
    &#34;&#34;&#34;Provides access to a specified user’s folders in their stored format.

    Args:
        name: (optional) Name to filter by
        structure: (optional) Structure type of the folders
        ids: (optional) Array of folder IDs to get, separated by a comma (,) and without spaces
        fields: (optional) Whitelist of fields to return for each document.
            Fields Can also define which fields to exclude by prefixing field names with -
        sort: (optional) Field by which the results should be sorted.
            Ascending by default, descending if prefixed by -
        skip: (optional) Number of results to skip from the start of the data set.
            Skip is to be used with the limit parameter for paging
        limit: (optional) How many results should be returned.
            limit is to be used with the skip parameter for paging
        expand: (optional) List of fields that should be expanded (substitue their IDs with actual objects).
            May be nested using the resource.subResource format

    Returns:
         An array of folders matching the search criteria
    &#34;&#34;&#34;
    ret_arr = []
    query_params = {
        &#39;name&#39;: name,
        &#39;structure&#39;: structure,
        &#39;ids&#39;: ids,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit,
        &#39;expand&#39;: expand
    }

    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/folders&#39;, query_params=query_params)

    # Sisense Rest API always returns the root folder, so we filter it out when looking by name
    if name:
        for folder in resp_json:
            if folder[&#39;name&#39;] == name:
                ret_arr.append(PySenseFolder.Folder(self, folder))
    else:
        for folder in resp_json:
            ret_arr.append(PySenseFolder.Folder(self, folder))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_group_by_id"><code class="name flex">
<span>def <span class="ident">get_group_by_id</span></span>(<span>self, group_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a group by id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group_by_id(self, group_id):
    &#34;&#34;&#34;Get a group by id&#34;&#34;&#34;
    if group_id is None:
        return None
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/groups/{}&#39;.format(group_id))
    return PySenseGroup.Group(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_groups"><code class="name flex">
<span>def <span class="ident">get_groups</span></span>(<span>self, *, name=None, mail=None, role=None, origin=None, ids=None, fields=None, sort=None, skip=None, limit=None, expand=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of user groups with their details.
The results can be filtered by different parameters such as group name or origin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>(optional) Group name to filter by</dd>
<dt><strong><code>mail</code></strong></dt>
<dd>(optional) Group email to filter by</dd>
<dt><strong><code>role</code></strong></dt>
<dd>(optional) Group role to filter by</dd>
<dt><strong><code>origin</code></strong></dt>
<dd>(optional) Group origin to filter by (ad or sisense)</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>(optional) Array of group IDs to filter by</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>(optional) Whitelist of fields to return for each document.
Fields can also define which fields to exclude by prefixing field names with -</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>(optional) Field by which the results should be sorted.
Ascending by default, descending if prefixed by -</dd>
<dt><strong><code>skip</code></strong></dt>
<dd>(optional) Number of results to skip from the start of the data set.
Skip is to be used with the limit parameter for paging</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>(optional) How many results should be returned.
limit is to be used with the skip parameter for paging</dd>
<dt><strong><code>expand</code></strong></dt>
<dd>(optional) List of fields that should be expanded (substitures their IDs with actual objects).
May be nested using the resource.subResource format</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Array of found groups</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_groups(self, *, name=None, mail=None, role=None, origin=None, ids=None, fields=None,
               sort=None, skip=None, limit=None, expand=None):
    &#34;&#34;&#34;Returns a list of user groups with their details.
    The results can be filtered by different parameters such as group name or origin.

    Args:
        name: (optional) Group name to filter by
        mail: (optional) Group email to filter by
        role: (optional) Group role to filter by
        origin: (optional) Group origin to filter by (ad or sisense)
        ids: (optional) Array of group IDs to filter by
        fields: (optional) Whitelist of fields to return for each document.
            Fields can also define which fields to exclude by prefixing field names with -
        sort: (optional) Field by which the results should be sorted.
            Ascending by default, descending if prefixed by -
        skip: (optional) Number of results to skip from the start of the data set.
            Skip is to be used with the limit parameter for paging
        limit: (optional) How many results should be returned.
            limit is to be used with the skip parameter for paging
        expand: (optional) List of fields that should be expanded (substitures their IDs with actual objects).
            May be nested using the resource.subResource format

    Returns:
        Array of found groups
    &#34;&#34;&#34;

    query_params = {
        &#39;name&#39;: name,
        &#39;mail&#39;: mail,
        &#39;roleId&#39;: self.get_role_id(role),
        &#39;origin&#39;: origin,
        &#39;ids&#39;: ids,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit,
        &#39;expand&#39;: expand
    }
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/groups&#39;, query_params=query_params)

    ret_arr = []
    for group in resp_json:
        ret_arr.append(PySenseGroup.Group(self, group))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_groups_by_name"><code class="name flex">
<span>def <span class="ident">get_groups_by_name</span></span>(<span>self, group_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array of groups matching the given names</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group_names</code></strong></dt>
<dd>One to many group names</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_groups_by_name(self, group_names):
    &#34;&#34;&#34;Returns an array of groups matching the given names

    Args:
        group_names: One to many group names
    &#34;&#34;&#34;
    if group_names is None:
        return []

    server_groups = self.get_groups()
    ret = []
    group_names = PySenseUtils.make_iterable(group_names)
    for group in server_groups:
        if group.get_name() in group_names:
            ret.append(group)
    return ret</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_plugins"><code class="name flex">
<span>def <span class="ident">get_plugins</span></span>(<span>self, *, order_by=None, desc=None, search=None, skip=None, limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all plugins installed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order_by</code></strong></dt>
<dd>(optional) Filter by provided field</dd>
<dt><strong><code>desc</code></strong></dt>
<dd>(optional) Order by descending/ascending (boolean)</dd>
<dt><strong><code>search</code></strong></dt>
<dd>(optional) Filter according to provided string</dd>
<dt><strong><code>skip</code></strong></dt>
<dd>(optional) Number of results to skip from the start of the data set.
Skip is to be used with the limit parameter for paging.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>(optional) How many results should be returned. limit is to be used with the skip parameter for paging</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An array of plugins</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plugins(self, *, order_by=None, desc=None, search=None, skip=None, limit=None):
    &#34;&#34;&#34;Get all plugins installed.

    Args:
        order_by: (optional) Filter by provided field
        desc: (optional) Order by descending/ascending (boolean)
        search: (optional) Filter according to provided string
        skip: (optional) Number of results to skip from the start of the data set.
            Skip is to be used with the limit parameter for paging.
        limit: (optional) How many results should be returned. limit is to be used with the skip parameter for paging

    Returns:
        An array of plugins
    &#34;&#34;&#34;
    query_params = {
        &#39;orderby&#39;: order_by,
        &#39;desc&#39;: desc,
        &#39;search&#39;: search,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit
    }
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/plugins&#39;, query_params=query_params)
    ret_arr = []
    for plugin in resp_json[&#39;plugins&#39;]:
        ret_arr.append((PySensePlugin.Plugin(self, plugin)))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_role_id"><code class="name flex">
<span>def <span class="ident">get_role_id</span></span>(<span>self, role_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the role id for the given role name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_role_id(self, role_name):
    &#34;&#34;&#34;Get the role id for the given role name&#34;&#34;&#34;
    if role_name is None:
        return None
    for item in self._roles:
        if role_name == item[&#39;name&#39;] or role_name == item[&#39;displayName&#39;]:
            return item[&#39;_id&#39;]
    raise PySenseException.PySenseException(&#39;No role with name {} found&#39;.format(role_name))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_role_name"><code class="name flex">
<span>def <span class="ident">get_role_name</span></span>(<span>self, role_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the role name for the given role id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_role_name(self, role_id):
    &#34;&#34;&#34;Get the role name for the given role id&#34;&#34;&#34;

    for item in self._roles:
        if role_id == item[&#39;_id&#39;]:
            return item[&#39;displayName&#39;]
    raise PySenseException.PySenseException(&#39;No role with id {} found&#39;.format(role_id))</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_user_by_email"><code class="name flex">
<span>def <span class="ident">get_user_by_email</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a single user based on email</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_by_email(self, email):
    &#34;&#34;&#34;Returns a single user based on email&#34;&#34;&#34;
    users = self.get_users(email=email)
    if len(users) == 0:
        None
    elif len(users) &gt; 1:
        raise PySenseException.PySenseException(&#39;{} users with email {} found. &#39;.format(len(users), email))
    else:
        return users[0]</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_user_by_id"><code class="name flex">
<span>def <span class="ident">get_user_by_id</span></span>(<span>self, user_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a single user based on id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_by_id(self, user_id):
    &#34;&#34;&#34;Returns a single user based on id&#34;&#34;&#34;
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users/{}&#39;.format(user_id))
    return PySenseUser.User(self, resp_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.get_users"><code class="name flex">
<span>def <span class="ident">get_users</span></span>(<span>self, *, user_name=None, email=None, first_name=None, last_name=None, role_name=None, group=None, active=None, origin=None, ids=None, fields=[], sort=None, skip=None, limit=None, expand=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of users.</p>
<p>Results can be filtered by parameters such as username and email.
The expandable fields for the user object are groups, adgroups and role.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_name</code></strong></dt>
<dd>(optional) Username to filter by</dd>
<dt><strong><code>email</code></strong></dt>
<dd>(optional) Email to filter by</dd>
<dt><strong><code>first_name</code></strong></dt>
<dd>(optional) First name to filter by</dd>
<dt><strong><code>last_name</code></strong></dt>
<dd>(optional) Last name to filter by</dd>
<dt><strong><code>role_name</code></strong></dt>
<dd>(optional) Role filter by</dd>
<dt><strong><code>group</code></strong></dt>
<dd>(optional) Group to filter by</dd>
<dt><strong><code>active</code></strong></dt>
<dd>(optional) User state to filter by (true for active users, false for inactive users)</dd>
<dt><strong><code>origin</code></strong></dt>
<dd>(optional) User origin to filter by (ad for active directory or sisense)</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>(optional) Array of user ids to get</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>(optional) An array of fields to return for each document.
Fields can also define which fields to exclude by prefixing field names with -</dd>
<dt><strong><code>sort</code></strong></dt>
<dd>(optional) Field by which the results should be sorted.
Ascending by default, descending if prefixed by -</dd>
<dt><strong><code>skip</code></strong></dt>
<dd>(optional) Number of results to skip from the start of the data set.
Skip is to be used with the limit parameter for paging</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>(optional) How many results should be returned.
limit is to be used with the skip parameter for paging</dd>
<dt><strong><code>expand</code></strong></dt>
<dd>(optional) List of fields that should be expanded (substitutes their IDs with actual objects).
May be nested using the resource.subResource format</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An array of PySenseUser.User objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users(self, *, user_name=None, email=None, first_name=None, last_name=None, role_name=None, group=None,
              active=None, origin=None, ids=None, fields=[], sort=None, skip=None, limit=None, expand=None):
    &#34;&#34;&#34;Returns a list of users.

    Results can be filtered by parameters such as username and email.
    The expandable fields for the user object are groups, adgroups and role.

    Args:
        user_name: (optional) Username to filter by
        email: (optional) Email to filter by
        first_name: (optional) First name to filter by
        last_name: (optional) Last name to filter by
        role_name: (optional) Role filter by
        group: (optional) Group to filter by
        active: (optional) User state to filter by (true for active users, false for inactive users)
        origin: (optional) User origin to filter by (ad for active directory or sisense)
        ids: (optional) Array of user ids to get
        fields: (optional) An array of fields to return for each document.
            Fields can also define which fields to exclude by prefixing field names with -
        sort: (optional) Field by which the results should be sorted.
            Ascending by default, descending if prefixed by -
        skip: (optional) Number of results to skip from the start of the data set.
            Skip is to be used with the limit parameter for paging
        limit: (optional) How many results should be returned.
            limit is to be used with the skip parameter for paging
        expand: (optional) List of fields that should be expanded (substitutes their IDs with actual objects).
            May be nested using the resource.subResource format

    Returns:
         An array of PySenseUser.User objects
    &#34;&#34;&#34;

    fields = PySenseUtils.make_iterable(fields)
    fields.extend(
        [&#39;_id&#39;, &#39;lastLogin&#39;, &#39;groups&#39;, &#39;email&#39;, &#39;userName&#39;, &#39;firstName&#39;, &#39;lastName&#39;, &#39;roleId&#39;, &#39;preferences&#39;]
    )
    fields = list(dict.fromkeys(fields))
    query_params = {
        &#39;userName&#39;: user_name,
        &#39;email&#39;: email,
        &#39;firstName&#39;: first_name,
        &#39;lastName&#39;: last_name,
        &#39;role&#39;: self.get_role_id(role_name),
        &#39;group&#39;: group,
        &#39;active&#39;: active,
        &#39;origin&#39;: origin,
        &#39;ids&#39;: ids,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit,
        &#39;expand&#39;: expand
    }
    ret_arr = []
    resp_json = self.connector.rest_call(&#39;get&#39;, &#39;api/v1/users&#39;, query_params=query_params)
    for user in resp_json:
        ret_arr.append((PySenseUser.User(self, user)))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.set_branding"><code class="name flex">
<span>def <span class="ident">set_branding</span></span>(<span>self, branding)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the branding</p>
<h2 id="args">Args</h2>
<ul>
<li>branding: The PySense Branding object</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_branding(self, branding):
    &#34;&#34;&#34;Update the branding
    Args:
        - branding: The PySense Branding object
    &#34;&#34;&#34;
    self.connector.rest_call(&#39;post&#39;, &#39;api/branding&#39;, json_payload=branding.get_json())</code></pre>
</details>
</dd>
<dt id="PySense.PySense.PySense.set_debug"><code class="name flex">
<span>def <span class="ident">set_debug</span></span>(<span>self, debug)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable or disable logging of REST api calls to std out.</p>
<p>Use for debugging. Debug is false by default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_debug(self, debug):
    &#34;&#34;&#34;Enable or disable logging of REST api calls to std out.

    Use for debugging. Debug is false by default.
    &#34;&#34;&#34;
    self.connector.debug = debug</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PySense" href="index.html">PySense</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PySense.PySense.authenticate_by_file" href="#PySense.PySense.authenticate_by_file">authenticate_by_file</a></code></li>
<li><code><a title="PySense.PySense.authenticate_by_password" href="#PySense.PySense.authenticate_by_password">authenticate_by_password</a></code></li>
<li><code><a title="PySense.PySense.authenticate_by_token" href="#PySense.PySense.authenticate_by_token">authenticate_by_token</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PySense.PySense.PySense" href="#PySense.PySense.PySense">PySense</a></code></h4>
<ul class="">
<li><code><a title="PySense.PySense.PySense.add_connection" href="#PySense.PySense.PySense.add_connection">add_connection</a></code></li>
<li><code><a title="PySense.PySense.PySense.add_dashboards" href="#PySense.PySense.PySense.add_dashboards">add_dashboards</a></code></li>
<li><code><a title="PySense.PySense.PySense.add_data_model" href="#PySense.PySense.PySense.add_data_model">add_data_model</a></code></li>
<li><code><a title="PySense.PySense.PySense.add_groups" href="#PySense.PySense.PySense.add_groups">add_groups</a></code></li>
<li><code><a title="PySense.PySense.PySense.add_user" href="#PySense.PySense.PySense.add_user">add_user</a></code></li>
<li><code><a title="PySense.PySense.PySense.delete_connections" href="#PySense.PySense.PySense.delete_connections">delete_connections</a></code></li>
<li><code><a title="PySense.PySense.PySense.delete_dashboards" href="#PySense.PySense.PySense.delete_dashboards">delete_dashboards</a></code></li>
<li><code><a title="PySense.PySense.PySense.delete_data_model" href="#PySense.PySense.PySense.delete_data_model">delete_data_model</a></code></li>
<li><code><a title="PySense.PySense.PySense.delete_groups" href="#PySense.PySense.PySense.delete_groups">delete_groups</a></code></li>
<li><code><a title="PySense.PySense.PySense.delete_users" href="#PySense.PySense.PySense.delete_users">delete_users</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_branding" href="#PySense.PySense.PySense.get_branding">get_branding</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_connection_by_id" href="#PySense.PySense.PySense.get_connection_by_id">get_connection_by_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_connections" href="#PySense.PySense.PySense.get_connections">get_connections</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_dashboard_by_id" href="#PySense.PySense.PySense.get_dashboard_by_id">get_dashboard_by_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_dashboards" href="#PySense.PySense.PySense.get_dashboards">get_dashboards</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_data_models" href="#PySense.PySense.PySense.get_data_models">get_data_models</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_elasticube_by_name" href="#PySense.PySense.PySense.get_elasticube_by_name">get_elasticube_by_name</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_elasticubes" href="#PySense.PySense.PySense.get_elasticubes">get_elasticubes</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_folder_by_id" href="#PySense.PySense.PySense.get_folder_by_id">get_folder_by_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_folders" href="#PySense.PySense.PySense.get_folders">get_folders</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_group_by_id" href="#PySense.PySense.PySense.get_group_by_id">get_group_by_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_groups" href="#PySense.PySense.PySense.get_groups">get_groups</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_groups_by_name" href="#PySense.PySense.PySense.get_groups_by_name">get_groups_by_name</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_plugins" href="#PySense.PySense.PySense.get_plugins">get_plugins</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_role_id" href="#PySense.PySense.PySense.get_role_id">get_role_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_role_name" href="#PySense.PySense.PySense.get_role_name">get_role_name</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_user_by_email" href="#PySense.PySense.PySense.get_user_by_email">get_user_by_email</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_user_by_id" href="#PySense.PySense.PySense.get_user_by_id">get_user_by_id</a></code></li>
<li><code><a title="PySense.PySense.PySense.get_users" href="#PySense.PySense.PySense.get_users">get_users</a></code></li>
<li><code><a title="PySense.PySense.PySense.set_branding" href="#PySense.PySense.PySense.set_branding">set_branding</a></code></li>
<li><code><a title="PySense.PySense.PySense.set_debug" href="#PySense.PySense.PySense.set_debug">set_debug</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>