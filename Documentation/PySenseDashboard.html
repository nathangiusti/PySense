<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>PySense.PySenseDashboard API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PySense.PySenseDashboard</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import requests

from PySense import PySenseUtils
from PySense import PySenseWidget


class Dashboard:

    def __init__(self, host, token, dashboard_json):
        self._host = host
        self._token = token
        self._dashboard_json = dashboard_json

    def _reset(self, dashboard_json):
        self._dashboard_json = dashboard_json

    def get_id(self):
        &#34;&#34;&#34;
        Gets the dashboard&#39;s id 
  
        :return: The dashboard&#39;s id  
        &#34;&#34;&#34;
        
        return self._dashboard_json[&#39;oid&#39;]

    def get_name(self):
        &#34;&#34;&#34;
        Gets the dashboard&#39;s title  
  
        :return: The dashboards title   
        &#34;&#34;&#34;
        
        return self._dashboard_json[&#39;title&#39;]

    def get_dashboard_folder_id(self):
        &#34;&#34;&#34;
        Gets the dashboards folder id  
  
        :return: The folder id of the parent folder of the dashboard  
        &#34;&#34;&#34;
        
        return self._dashboard_json[&#39;parentFolder&#39;]

    def get_shares(self):
        &#34;&#34;&#34;
        Gets the dashboard shares json  
  
        :return: The dashboard shares json  
        &#34;&#34;&#34;

        resp = requests.get(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
            headers=self._token)
        PySenseUtils.parse_response(resp)
        return resp.json()

    def move_to_folder(self, folder):
        &#34;&#34;&#34;
        Move dashboard to given folder  
  
        :param folder: Folder object to move dashboard to, None to remove from folder  
        
        :return: True if successful  
        &#34;&#34;&#34;
        if folder:
            folder_oid = folder.get_folder_id()
        else:
            folder_oid = None
        resp = requests.patch(
            &#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
            headers=self._token, json={&#39;parentFolder&#39;: folder_oid})
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())
        return True

    def share_to_user(self, email, rule, subscribe):
        &#34;&#34;&#34;
        Share a dashboard to a user  
  
        :param email: The email address of the user  
        :param rule: The permission of the user on the dashboard (view, edit, etc)  
        :param subscribe: true or false, whether to subscribe the user to reports  
          
        :return: The updated share  
        &#34;&#34;&#34;

        user_id = PySenseUtils.get_user_id(self._host, self._token, email)
        shares = self.get_shares()
        shares[&#39;sharesTo&#39;].append({&#39;shareId&#39;: user_id, &#39;type&#39;: &#39;user&#39;, &#39;rule&#39;: rule, &#39;subscribe&#39;: subscribe})
        resp = requests.post(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
            headers=self._token, json=shares)
        PySenseUtils.parse_response(resp)
        return self.get_shares()

    def unshare_to_user(self, email):
        &#34;&#34;&#34;
        Unshare a dashboard to a user  
  
        :param email: The email address of the user  
           
        :return: The updated share  
        &#34;&#34;&#34;

        shares = self.get_shares()
        for i, share in enumerate(shares[&#39;sharesTo&#39;]):
            if share[&#39;email&#39;] == email:
                del shares[&#39;sharesTo&#39;][i]
        resp = requests.post(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
            headers=self._token, json=shares)
        PySenseUtils.parse_response(resp)
        return self.get_shares()

    def export_to_png(self, *, path=None, include_title=None, include_filters=None, include_ds=None, width=None):
        &#34;&#34;&#34;
        Get dashboard as png    
  
        Optional:
        :param path: Path to save location of png    
        :param include_title: Should dashboard title be included in the exported file  
        :param include_filters: Should dashboard filters be included in the exported file  
        :param include_ds: Should dashboard data source info be included in the exported file  
        :param width: Render width in pixels  
          
        :return: The path of the created file if provided or else the raw response obejct  
        &#34;&#34;&#34;
        
        param_string = PySenseUtils.build_query_string({
            &#39;includeTitle&#39;: include_title,
            &#39;includeFilters&#39;: include_filters,
            &#39;includeDs&#39;: include_ds,
            &#39;width&#39;: width
        })
        resp = requests.get(
            &#39;{}/api/v1/dashboards/{}/export/png?{}&#39;.format(self._host, self.get_id(), param_string),
            headers=self._token)
        PySenseUtils.parse_response(resp)
        if path is not None:
            with open(path, &#39;wb&#39;) as out_file:
                out_file.write(resp.content)
            return path
        else: 
            return resp.content

    def export_to_pdf(self, paper_format, paper_orientation, layout, *, path=None,
                      include_title=None, include_filters=None, include_ds=None, widget_id=None,
                      preview=None,
                      row_count=None, show_title=None, show_footer=None, title=None, title_size=None,
                      title_position=None):
        &#34;&#34;&#34;
        Get dashboard as pdf  
  
        :param paper_format: What paper format should be used while rendering the dashboard.  
        :param paper_orientation: What paper orientation should be used while rendering the dashboard  
        :param layout: What layout should be used while rendering the dashboard, as is or feed  
        
        Optional:
        :param path: Path to save location of pdf  
        :param include_title: Should dashboard title be included in the exported file  
        :param include_filters: Should dashboard filters be included in the exported file  
        :param include_ds: Should dashboard datasource info be included in the exported file  
        :param widget_id: Widget Id (Use only for Table and Pivot Widgets)  
        :param preview: Should use a new Pixel Perfect Reporting  
        :param row_count: Count of Table/Pivot rows to export  
        :param show_title: Should Table/Pivot Widget title be included in the exported file  
        :param show_footer: Should Table/Pivot Widget footer be included in the exported file  
        :param title: Table/Pivot Widget title text in the exported file  
        :param title_size: Table/Pivot widget title size in the exported file  
        :param title_position: Table/Pivot widget title position in the exported file  
        :return: The path of the created file if provided, else the raw content
        &#34;&#34;&#34;
        
        param_string = PySenseUtils.build_query_string({
            &#39;paperFormat&#39;: paper_format,
            &#39;paperOrientation&#39;: paper_orientation,
            &#39;layout&#39;: layout,
            &#39;includeTitle&#39;: include_title,
            &#39;includeFilters&#39;: include_filters,
            &#39;includeDs&#39;: include_ds,
            &#39;widgetid&#39;: widget_id,
            &#39;preview&#39;: preview,
            &#39;rowCount&#39;: row_count,
            &#39;showTitle&#39;: show_title,
            &#39;showFooter&#39;: show_footer,
            &#39;title&#39;: title,
            &#39;titleSize&#39;: title_size,
            &#39;titlePosition&#39;: title_position
        })
        resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/pdf?{}&#39;
                            .format(self._host, self.get_id(), param_string), headers=self._token)
        PySenseUtils.parse_response(resp)
        if path is not None:
            with open(path, &#39;wb&#39;) as out_file:
                out_file.write(resp.content)
            return path
        else:
            return resp.content

    def export_to_dash(self, *, path=None):
        &#34;&#34;&#34;
        Get dashboard as dash file  
  
        Optional:
        :param path: Path to save location of dash file  
        
        :return: The path of the created file if path provided, else the raw content
        &#34;&#34;&#34;
        
        resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/dash&#39;.format(self._host, self.get_id()),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        if path is not None:
            with open(path, &#39;wb&#39;) as out_file:
                out_file.write(resp.content)
            return path
        else:
            return resp.content

    def get_widgets(self, *, title=None, type=None, subtype=None,
                    fields=None, sort=None, skip=None, limit=None):
        &#34;&#34;&#34;
        Returns an array of a dashboard’s widgets.  
  
        Optional:
        :param title: Widget title to filter by  
        :param type: Widget type to filter by  
        :param subtype: Widget sub-type to filter by  
        :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
            by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param skip: Number of results to skip from the start of the data set. skip is to be used with the limit  
            parameter for paging  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
          
        :return: An array of widget objects  
        &#34;&#34;&#34;
        
        param_string = PySenseUtils.build_query_string({
            &#39;title&#39;: title,
            &#39;type&#39;: type,
            &#39;subtype&#39;: subtype,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        })

        resp = requests.get(
            &#39;{}/api/v1/dashboards/{}/widgets?{}&#39;.format(self._host, self.get_id(), param_string),
            headers=self._token)

        PySenseUtils.parse_response(resp)
        ret_arr = []
        widgets_json = json.loads(resp.content)
        for widget in widgets_json:
            ret_arr.append(PySenseWidget.Widget(self._host, self._token, widget))
        return ret_arr

    def get_widget_by_id(self, widget_id, *, fields=None):
        &#34;&#34;&#34;
        Returns a specific widget (by ID) from a specific dashboard.  
    
        :param widget_id: The ID of the widget to get   
           
        Optional:  
        :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
            by prefixing field names with -  
            
        :return: A widget object  
        &#34;&#34;&#34;
        
        param_string = PySenseUtils.build_query_string({
            &#39;fields&#39;: fields
        })

        resp = requests.get(&#39;{}/api/v1/dashboards/{}/widgets/{}?{}&#39;.format(self._host, self.get_id(),
                                                                           widget_id, param_string),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))

    def add_widget(self, widget):
        &#34;&#34;&#34;
        Adds the provided widget object to the dashboard  

        :param widget: widget object to add  
        
        :return: The widget added to the dashboard  
        &#34;&#34;&#34;
        
        resp = requests.post(&#39;{}/api/v1/dashboards/{}/widgets&#39;.format(self._host, self.get_id()),
                             headers=self._token, json=widget.get_widget_json())
        PySenseUtils.parse_response(resp)
        return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))

    def delete_widget(self, widget_id):
        &#34;&#34;&#34;  
        Deletes a widget with the provided ID from it’s dashboard.  
  
        :param widget_id: The ID of the widget to delete  
        &#34;&#34;&#34;  
        
        resp = requests.delete(&#39;{}/api/v1/dashboards/{}/widgets/{}&#39;
                               .format(self._host, self.get_id(), widget_id), headers=self._token)
        PySenseUtils.parse_response(resp)
        # Get the updated dashboard from source and refresh object
        resp = requests.get(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())

    def does_widget_exist(self, widget_id):  
        &#34;&#34;&#34;
        Returns whether or not a widget with the given id is in the dashboard  
          
        :param widget_id: The widget id to look for  
          
        :return: True if found, false if not.  
        &#34;&#34;&#34;
         
        try:
            self.get_widget_by_id(widget_id)
        except PySenseUtils.RestError:
            return False
        else:
            return True

    def remove_ghost_widgets(self):
        &#34;&#34;&#34;
        Removes ghost widgets from dashboard  
        &#34;&#34;&#34;
        
        patch_json = {&#34;layout&#34;: self._dashboard_json[&#39;layout&#39;]}
        modified = True
        while modified:
            modified = False
            for l, column in enumerate(patch_json[&#39;layout&#39;][&#39;columns&#39;]):
                for k, cell in enumerate(column[&#39;cells&#39;]):
                    for j, sub_cell in enumerate(cell[&#39;subcells&#39;]):
                        for i, element in enumerate(sub_cell[&#39;elements&#39;]):
                            if not self.does_widget_exist(element[&#39;widgetid&#39;]):
                                sub_cell[&#39;elements&#39;].pop(i)
                                modified = True
                        if len(sub_cell[&#39;elements&#39;]) == 0:
                            cell[&#39;subcells&#39;].pop(j)
                    if len(cell[&#39;subcells&#39;]) == 0:
                        column[&#39;cells&#39;].pop(k)
                if len(column[&#39;cells&#39;]) == 0:
                    patch_json[&#39;layout&#39;][&#39;columns&#39;].pop(l)
        resp = requests.patch(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
                              headers=self._token, json=patch_json)
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PySense.PySenseDashboard.Dashboard"><code class="flex name class">
<span>class <span class="ident">Dashboard</span></span>
<span>(</span><span>host, token, dashboard_json)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dashboard:

    def __init__(self, host, token, dashboard_json):
        self._host = host
        self._token = token
        self._dashboard_json = dashboard_json

    def _reset(self, dashboard_json):
        self._dashboard_json = dashboard_json

    def get_id(self):
        &#34;&#34;&#34;
        Gets the dashboard&#39;s id 
  
        :return: The dashboard&#39;s id  
        &#34;&#34;&#34;
        
        return self._dashboard_json[&#39;oid&#39;]

    def get_name(self):
        &#34;&#34;&#34;
        Gets the dashboard&#39;s title  
  
        :return: The dashboards title   
        &#34;&#34;&#34;
        
        return self._dashboard_json[&#39;title&#39;]

    def get_dashboard_folder_id(self):
        &#34;&#34;&#34;
        Gets the dashboards folder id  
  
        :return: The folder id of the parent folder of the dashboard  
        &#34;&#34;&#34;
        
        return self._dashboard_json[&#39;parentFolder&#39;]

    def get_shares(self):
        &#34;&#34;&#34;
        Gets the dashboard shares json  
  
        :return: The dashboard shares json  
        &#34;&#34;&#34;

        resp = requests.get(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
            headers=self._token)
        PySenseUtils.parse_response(resp)
        return resp.json()

    def move_to_folder(self, folder):
        &#34;&#34;&#34;
        Move dashboard to given folder  
  
        :param folder: Folder object to move dashboard to, None to remove from folder  
        
        :return: True if successful  
        &#34;&#34;&#34;
        if folder:
            folder_oid = folder.get_folder_id()
        else:
            folder_oid = None
        resp = requests.patch(
            &#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
            headers=self._token, json={&#39;parentFolder&#39;: folder_oid})
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())
        return True

    def share_to_user(self, email, rule, subscribe):
        &#34;&#34;&#34;
        Share a dashboard to a user  
  
        :param email: The email address of the user  
        :param rule: The permission of the user on the dashboard (view, edit, etc)  
        :param subscribe: true or false, whether to subscribe the user to reports  
          
        :return: The updated share  
        &#34;&#34;&#34;

        user_id = PySenseUtils.get_user_id(self._host, self._token, email)
        shares = self.get_shares()
        shares[&#39;sharesTo&#39;].append({&#39;shareId&#39;: user_id, &#39;type&#39;: &#39;user&#39;, &#39;rule&#39;: rule, &#39;subscribe&#39;: subscribe})
        resp = requests.post(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
            headers=self._token, json=shares)
        PySenseUtils.parse_response(resp)
        return self.get_shares()

    def unshare_to_user(self, email):
        &#34;&#34;&#34;
        Unshare a dashboard to a user  
  
        :param email: The email address of the user  
           
        :return: The updated share  
        &#34;&#34;&#34;

        shares = self.get_shares()
        for i, share in enumerate(shares[&#39;sharesTo&#39;]):
            if share[&#39;email&#39;] == email:
                del shares[&#39;sharesTo&#39;][i]
        resp = requests.post(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
            headers=self._token, json=shares)
        PySenseUtils.parse_response(resp)
        return self.get_shares()

    def export_to_png(self, *, path=None, include_title=None, include_filters=None, include_ds=None, width=None):
        &#34;&#34;&#34;
        Get dashboard as png    
  
        Optional:
        :param path: Path to save location of png    
        :param include_title: Should dashboard title be included in the exported file  
        :param include_filters: Should dashboard filters be included in the exported file  
        :param include_ds: Should dashboard data source info be included in the exported file  
        :param width: Render width in pixels  
          
        :return: The path of the created file if provided or else the raw response obejct  
        &#34;&#34;&#34;
        
        param_string = PySenseUtils.build_query_string({
            &#39;includeTitle&#39;: include_title,
            &#39;includeFilters&#39;: include_filters,
            &#39;includeDs&#39;: include_ds,
            &#39;width&#39;: width
        })
        resp = requests.get(
            &#39;{}/api/v1/dashboards/{}/export/png?{}&#39;.format(self._host, self.get_id(), param_string),
            headers=self._token)
        PySenseUtils.parse_response(resp)
        if path is not None:
            with open(path, &#39;wb&#39;) as out_file:
                out_file.write(resp.content)
            return path
        else: 
            return resp.content

    def export_to_pdf(self, paper_format, paper_orientation, layout, *, path=None,
                      include_title=None, include_filters=None, include_ds=None, widget_id=None,
                      preview=None,
                      row_count=None, show_title=None, show_footer=None, title=None, title_size=None,
                      title_position=None):
        &#34;&#34;&#34;
        Get dashboard as pdf  
  
        :param paper_format: What paper format should be used while rendering the dashboard.  
        :param paper_orientation: What paper orientation should be used while rendering the dashboard  
        :param layout: What layout should be used while rendering the dashboard, as is or feed  
        
        Optional:
        :param path: Path to save location of pdf  
        :param include_title: Should dashboard title be included in the exported file  
        :param include_filters: Should dashboard filters be included in the exported file  
        :param include_ds: Should dashboard datasource info be included in the exported file  
        :param widget_id: Widget Id (Use only for Table and Pivot Widgets)  
        :param preview: Should use a new Pixel Perfect Reporting  
        :param row_count: Count of Table/Pivot rows to export  
        :param show_title: Should Table/Pivot Widget title be included in the exported file  
        :param show_footer: Should Table/Pivot Widget footer be included in the exported file  
        :param title: Table/Pivot Widget title text in the exported file  
        :param title_size: Table/Pivot widget title size in the exported file  
        :param title_position: Table/Pivot widget title position in the exported file  
        :return: The path of the created file if provided, else the raw content
        &#34;&#34;&#34;
        
        param_string = PySenseUtils.build_query_string({
            &#39;paperFormat&#39;: paper_format,
            &#39;paperOrientation&#39;: paper_orientation,
            &#39;layout&#39;: layout,
            &#39;includeTitle&#39;: include_title,
            &#39;includeFilters&#39;: include_filters,
            &#39;includeDs&#39;: include_ds,
            &#39;widgetid&#39;: widget_id,
            &#39;preview&#39;: preview,
            &#39;rowCount&#39;: row_count,
            &#39;showTitle&#39;: show_title,
            &#39;showFooter&#39;: show_footer,
            &#39;title&#39;: title,
            &#39;titleSize&#39;: title_size,
            &#39;titlePosition&#39;: title_position
        })
        resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/pdf?{}&#39;
                            .format(self._host, self.get_id(), param_string), headers=self._token)
        PySenseUtils.parse_response(resp)
        if path is not None:
            with open(path, &#39;wb&#39;) as out_file:
                out_file.write(resp.content)
            return path
        else:
            return resp.content

    def export_to_dash(self, *, path=None):
        &#34;&#34;&#34;
        Get dashboard as dash file  
  
        Optional:
        :param path: Path to save location of dash file  
        
        :return: The path of the created file if path provided, else the raw content
        &#34;&#34;&#34;
        
        resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/dash&#39;.format(self._host, self.get_id()),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        if path is not None:
            with open(path, &#39;wb&#39;) as out_file:
                out_file.write(resp.content)
            return path
        else:
            return resp.content

    def get_widgets(self, *, title=None, type=None, subtype=None,
                    fields=None, sort=None, skip=None, limit=None):
        &#34;&#34;&#34;
        Returns an array of a dashboard’s widgets.  
  
        Optional:
        :param title: Widget title to filter by  
        :param type: Widget type to filter by  
        :param subtype: Widget sub-type to filter by  
        :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
            by prefixing field names with -  
        :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
        :param skip: Number of results to skip from the start of the data set. skip is to be used with the limit  
            parameter for paging  
        :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
          
        :return: An array of widget objects  
        &#34;&#34;&#34;
        
        param_string = PySenseUtils.build_query_string({
            &#39;title&#39;: title,
            &#39;type&#39;: type,
            &#39;subtype&#39;: subtype,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        })

        resp = requests.get(
            &#39;{}/api/v1/dashboards/{}/widgets?{}&#39;.format(self._host, self.get_id(), param_string),
            headers=self._token)

        PySenseUtils.parse_response(resp)
        ret_arr = []
        widgets_json = json.loads(resp.content)
        for widget in widgets_json:
            ret_arr.append(PySenseWidget.Widget(self._host, self._token, widget))
        return ret_arr

    def get_widget_by_id(self, widget_id, *, fields=None):
        &#34;&#34;&#34;
        Returns a specific widget (by ID) from a specific dashboard.  
    
        :param widget_id: The ID of the widget to get   
           
        Optional:  
        :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
            by prefixing field names with -  
            
        :return: A widget object  
        &#34;&#34;&#34;
        
        param_string = PySenseUtils.build_query_string({
            &#39;fields&#39;: fields
        })

        resp = requests.get(&#39;{}/api/v1/dashboards/{}/widgets/{}?{}&#39;.format(self._host, self.get_id(),
                                                                           widget_id, param_string),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))

    def add_widget(self, widget):
        &#34;&#34;&#34;
        Adds the provided widget object to the dashboard  

        :param widget: widget object to add  
        
        :return: The widget added to the dashboard  
        &#34;&#34;&#34;
        
        resp = requests.post(&#39;{}/api/v1/dashboards/{}/widgets&#39;.format(self._host, self.get_id()),
                             headers=self._token, json=widget.get_widget_json())
        PySenseUtils.parse_response(resp)
        return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))

    def delete_widget(self, widget_id):
        &#34;&#34;&#34;  
        Deletes a widget with the provided ID from it’s dashboard.  
  
        :param widget_id: The ID of the widget to delete  
        &#34;&#34;&#34;  
        
        resp = requests.delete(&#39;{}/api/v1/dashboards/{}/widgets/{}&#39;
                               .format(self._host, self.get_id(), widget_id), headers=self._token)
        PySenseUtils.parse_response(resp)
        # Get the updated dashboard from source and refresh object
        resp = requests.get(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())

    def does_widget_exist(self, widget_id):  
        &#34;&#34;&#34;
        Returns whether or not a widget with the given id is in the dashboard  
          
        :param widget_id: The widget id to look for  
          
        :return: True if found, false if not.  
        &#34;&#34;&#34;
         
        try:
            self.get_widget_by_id(widget_id)
        except PySenseUtils.RestError:
            return False
        else:
            return True

    def remove_ghost_widgets(self):
        &#34;&#34;&#34;
        Removes ghost widgets from dashboard  
        &#34;&#34;&#34;
        
        patch_json = {&#34;layout&#34;: self._dashboard_json[&#39;layout&#39;]}
        modified = True
        while modified:
            modified = False
            for l, column in enumerate(patch_json[&#39;layout&#39;][&#39;columns&#39;]):
                for k, cell in enumerate(column[&#39;cells&#39;]):
                    for j, sub_cell in enumerate(cell[&#39;subcells&#39;]):
                        for i, element in enumerate(sub_cell[&#39;elements&#39;]):
                            if not self.does_widget_exist(element[&#39;widgetid&#39;]):
                                sub_cell[&#39;elements&#39;].pop(i)
                                modified = True
                        if len(sub_cell[&#39;elements&#39;]) == 0:
                            cell[&#39;subcells&#39;].pop(j)
                    if len(cell[&#39;subcells&#39;]) == 0:
                        column[&#39;cells&#39;].pop(k)
                if len(column[&#39;cells&#39;]) == 0:
                    patch_json[&#39;layout&#39;][&#39;columns&#39;].pop(l)
        resp = requests.patch(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
                              headers=self._token, json=patch_json)
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PySense.PySenseDashboard.Dashboard.add_widget"><code class="name flex">
<span>def <span class="ident">add_widget</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds the provided widget object to the dashboard
</p>
<p>:param widget: widget object to add
</p>
<p>:return: The widget added to the dashboard</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_widget(self, widget):
    &#34;&#34;&#34;
    Adds the provided widget object to the dashboard  

    :param widget: widget object to add  
    
    :return: The widget added to the dashboard  
    &#34;&#34;&#34;
    
    resp = requests.post(&#39;{}/api/v1/dashboards/{}/widgets&#39;.format(self._host, self.get_id()),
                         headers=self._token, json=widget.get_widget_json())
    PySenseUtils.parse_response(resp)
    return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.delete_widget"><code class="name flex">
<span>def <span class="ident">delete_widget</span></span>(<span>self, widget_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a widget with the provided ID from it’s dashboard.
</p>
<p>:param widget_id: The ID of the widget to delete</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_widget(self, widget_id):
    &#34;&#34;&#34;  
    Deletes a widget with the provided ID from it’s dashboard.  

    :param widget_id: The ID of the widget to delete  
    &#34;&#34;&#34;  
    
    resp = requests.delete(&#39;{}/api/v1/dashboards/{}/widgets/{}&#39;
                           .format(self._host, self.get_id(), widget_id), headers=self._token)
    PySenseUtils.parse_response(resp)
    # Get the updated dashboard from source and refresh object
    resp = requests.get(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
                        headers=self._token)
    PySenseUtils.parse_response(resp)
    self._reset(resp.json())</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.does_widget_exist"><code class="name flex">
<span>def <span class="ident">does_widget_exist</span></span>(<span>self, widget_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns whether or not a widget with the given id is in the dashboard
</p>
<p>:param widget_id: The widget id to look for
</p>
<p>:return: True if found, false if not.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def does_widget_exist(self, widget_id):  
    &#34;&#34;&#34;
    Returns whether or not a widget with the given id is in the dashboard  
      
    :param widget_id: The widget id to look for  
      
    :return: True if found, false if not.  
    &#34;&#34;&#34;
     
    try:
        self.get_widget_by_id(widget_id)
    except PySenseUtils.RestError:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.export_to_dash"><code class="name flex">
<span>def <span class="ident">export_to_dash</span></span>(<span>self, *, path=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get dashboard as dash file
</p>
<p>Optional:
:param path: Path to save location of dash file
</p>
<p>:return: The path of the created file if path provided, else the raw content</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_to_dash(self, *, path=None):
    &#34;&#34;&#34;
    Get dashboard as dash file  

    Optional:
    :param path: Path to save location of dash file  
    
    :return: The path of the created file if path provided, else the raw content
    &#34;&#34;&#34;
    
    resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/dash&#39;.format(self._host, self.get_id()),
                        headers=self._token)
    PySenseUtils.parse_response(resp)
    if path is not None:
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path
    else:
        return resp.content</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.export_to_pdf"><code class="name flex">
<span>def <span class="ident">export_to_pdf</span></span>(<span>self, paper_format, paper_orientation, layout, *, path=None, include_title=None, include_filters=None, include_ds=None, widget_id=None, preview=None, row_count=None, show_title=None, show_footer=None, title=None, title_size=None, title_position=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get dashboard as pdf
</p>
<p>:param paper_format: What paper format should be used while rendering the dashboard.<br>
:param paper_orientation: What paper orientation should be used while rendering the dashboard<br>
:param layout: What layout should be used while rendering the dashboard, as is or feed
</p>
<p>Optional:
:param path: Path to save location of pdf<br>
:param include_title: Should dashboard title be included in the exported file<br>
:param include_filters: Should dashboard filters be included in the exported file<br>
:param include_ds: Should dashboard datasource info be included in the exported file<br>
:param widget_id: Widget Id (Use only for Table and Pivot Widgets)<br>
:param preview: Should use a new Pixel Perfect Reporting<br>
:param row_count: Count of Table/Pivot rows to export<br>
:param show_title: Should Table/Pivot Widget title be included in the exported file<br>
:param show_footer: Should Table/Pivot Widget footer be included in the exported file<br>
:param title: Table/Pivot Widget title text in the exported file<br>
:param title_size: Table/Pivot widget title size in the exported file<br>
:param title_position: Table/Pivot widget title position in the exported file<br>
:return: The path of the created file if provided, else the raw content</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_to_pdf(self, paper_format, paper_orientation, layout, *, path=None,
                  include_title=None, include_filters=None, include_ds=None, widget_id=None,
                  preview=None,
                  row_count=None, show_title=None, show_footer=None, title=None, title_size=None,
                  title_position=None):
    &#34;&#34;&#34;
    Get dashboard as pdf  

    :param paper_format: What paper format should be used while rendering the dashboard.  
    :param paper_orientation: What paper orientation should be used while rendering the dashboard  
    :param layout: What layout should be used while rendering the dashboard, as is or feed  
    
    Optional:
    :param path: Path to save location of pdf  
    :param include_title: Should dashboard title be included in the exported file  
    :param include_filters: Should dashboard filters be included in the exported file  
    :param include_ds: Should dashboard datasource info be included in the exported file  
    :param widget_id: Widget Id (Use only for Table and Pivot Widgets)  
    :param preview: Should use a new Pixel Perfect Reporting  
    :param row_count: Count of Table/Pivot rows to export  
    :param show_title: Should Table/Pivot Widget title be included in the exported file  
    :param show_footer: Should Table/Pivot Widget footer be included in the exported file  
    :param title: Table/Pivot Widget title text in the exported file  
    :param title_size: Table/Pivot widget title size in the exported file  
    :param title_position: Table/Pivot widget title position in the exported file  
    :return: The path of the created file if provided, else the raw content
    &#34;&#34;&#34;
    
    param_string = PySenseUtils.build_query_string({
        &#39;paperFormat&#39;: paper_format,
        &#39;paperOrientation&#39;: paper_orientation,
        &#39;layout&#39;: layout,
        &#39;includeTitle&#39;: include_title,
        &#39;includeFilters&#39;: include_filters,
        &#39;includeDs&#39;: include_ds,
        &#39;widgetid&#39;: widget_id,
        &#39;preview&#39;: preview,
        &#39;rowCount&#39;: row_count,
        &#39;showTitle&#39;: show_title,
        &#39;showFooter&#39;: show_footer,
        &#39;title&#39;: title,
        &#39;titleSize&#39;: title_size,
        &#39;titlePosition&#39;: title_position
    })
    resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/pdf?{}&#39;
                        .format(self._host, self.get_id(), param_string), headers=self._token)
    PySenseUtils.parse_response(resp)
    if path is not None:
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path
    else:
        return resp.content</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.export_to_png"><code class="name flex">
<span>def <span class="ident">export_to_png</span></span>(<span>self, *, path=None, include_title=None, include_filters=None, include_ds=None, width=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get dashboard as png
</p>
<p>Optional:
:param path: Path to save location of png
<br>
:param include_title: Should dashboard title be included in the exported file<br>
:param include_filters: Should dashboard filters be included in the exported file<br>
:param include_ds: Should dashboard data source info be included in the exported file<br>
:param width: Render width in pixels
</p>
<p>:return: The path of the created file if provided or else the raw response obejct</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_to_png(self, *, path=None, include_title=None, include_filters=None, include_ds=None, width=None):
    &#34;&#34;&#34;
    Get dashboard as png    

    Optional:
    :param path: Path to save location of png    
    :param include_title: Should dashboard title be included in the exported file  
    :param include_filters: Should dashboard filters be included in the exported file  
    :param include_ds: Should dashboard data source info be included in the exported file  
    :param width: Render width in pixels  
      
    :return: The path of the created file if provided or else the raw response obejct  
    &#34;&#34;&#34;
    
    param_string = PySenseUtils.build_query_string({
        &#39;includeTitle&#39;: include_title,
        &#39;includeFilters&#39;: include_filters,
        &#39;includeDs&#39;: include_ds,
        &#39;width&#39;: width
    })
    resp = requests.get(
        &#39;{}/api/v1/dashboards/{}/export/png?{}&#39;.format(self._host, self.get_id(), param_string),
        headers=self._token)
    PySenseUtils.parse_response(resp)
    if path is not None:
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path
    else: 
        return resp.content</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_folder_id"><code class="name flex">
<span>def <span class="ident">get_dashboard_folder_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the dashboards folder id
</p>
<p>:return: The folder id of the parent folder of the dashboard</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_folder_id(self):
    &#34;&#34;&#34;
    Gets the dashboards folder id  

    :return: The folder id of the parent folder of the dashboard  
    &#34;&#34;&#34;
    
    return self._dashboard_json[&#39;parentFolder&#39;]</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the dashboard's id </p>
<p>:return: The dashboard's id</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self):
    &#34;&#34;&#34;
    Gets the dashboard&#39;s id 

    :return: The dashboard&#39;s id  
    &#34;&#34;&#34;
    
    return self._dashboard_json[&#39;oid&#39;]</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the dashboard's title
</p>
<p>:return: The dashboards title</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self):
    &#34;&#34;&#34;
    Gets the dashboard&#39;s title  

    :return: The dashboards title   
    &#34;&#34;&#34;
    
    return self._dashboard_json[&#39;title&#39;]</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_shares"><code class="name flex">
<span>def <span class="ident">get_shares</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the dashboard shares json
</p>
<p>:return: The dashboard shares json</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shares(self):
    &#34;&#34;&#34;
    Gets the dashboard shares json  

    :return: The dashboard shares json  
    &#34;&#34;&#34;

    resp = requests.get(
        &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
        headers=self._token)
    PySenseUtils.parse_response(resp)
    return resp.json()</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_widget_by_id"><code class="name flex">
<span>def <span class="ident">get_widget_by_id</span></span>(<span>self, widget_id, *, fields=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a specific widget (by ID) from a specific dashboard.
</p>
<p>:param widget_id: The ID of the widget to get
</p>
<p>Optional:<br>
:param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude<br>
by prefixing field names with -
</p>
<p>:return: A widget object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_widget_by_id(self, widget_id, *, fields=None):
    &#34;&#34;&#34;
    Returns a specific widget (by ID) from a specific dashboard.  

    :param widget_id: The ID of the widget to get   
       
    Optional:  
    :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
        by prefixing field names with -  
        
    :return: A widget object  
    &#34;&#34;&#34;
    
    param_string = PySenseUtils.build_query_string({
        &#39;fields&#39;: fields
    })

    resp = requests.get(&#39;{}/api/v1/dashboards/{}/widgets/{}?{}&#39;.format(self._host, self.get_id(),
                                                                       widget_id, param_string),
                        headers=self._token)
    PySenseUtils.parse_response(resp)
    return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_widgets"><code class="name flex">
<span>def <span class="ident">get_widgets</span></span>(<span>self, *, title=None, type=None, subtype=None, fields=None, sort=None, skip=None, limit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an array of a dashboard’s widgets.
</p>
<p>Optional:
:param title: Widget title to filter by<br>
:param type: Widget type to filter by<br>
:param subtype: Widget sub-type to filter by<br>
:param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude<br>
by prefixing field names with -<br>
:param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -<br>
:param skip: Number of results to skip from the start of the data set. skip is to be used with the limit<br>
parameter for paging<br>
:param limit: How many results should be returned. limit is to be used with the skip parameter for paging
</p>
<p>:return: An array of widget objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_widgets(self, *, title=None, type=None, subtype=None,
                fields=None, sort=None, skip=None, limit=None):
    &#34;&#34;&#34;
    Returns an array of a dashboard’s widgets.  

    Optional:
    :param title: Widget title to filter by  
    :param type: Widget type to filter by  
    :param subtype: Widget sub-type to filter by  
    :param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude  
        by prefixing field names with -  
    :param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -  
    :param skip: Number of results to skip from the start of the data set. skip is to be used with the limit  
        parameter for paging  
    :param limit: How many results should be returned. limit is to be used with the skip parameter for paging  
      
    :return: An array of widget objects  
    &#34;&#34;&#34;
    
    param_string = PySenseUtils.build_query_string({
        &#39;title&#39;: title,
        &#39;type&#39;: type,
        &#39;subtype&#39;: subtype,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit
    })

    resp = requests.get(
        &#39;{}/api/v1/dashboards/{}/widgets?{}&#39;.format(self._host, self.get_id(), param_string),
        headers=self._token)

    PySenseUtils.parse_response(resp)
    ret_arr = []
    widgets_json = json.loads(resp.content)
    for widget in widgets_json:
        ret_arr.append(PySenseWidget.Widget(self._host, self._token, widget))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.move_to_folder"><code class="name flex">
<span>def <span class="ident">move_to_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<section class="desc"><p>Move dashboard to given folder
</p>
<p>:param folder: Folder object to move dashboard to, None to remove from folder
</p>
<p>:return: True if successful</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to_folder(self, folder):
    &#34;&#34;&#34;
    Move dashboard to given folder  

    :param folder: Folder object to move dashboard to, None to remove from folder  
    
    :return: True if successful  
    &#34;&#34;&#34;
    if folder:
        folder_oid = folder.get_folder_id()
    else:
        folder_oid = None
    resp = requests.patch(
        &#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
        headers=self._token, json={&#39;parentFolder&#39;: folder_oid})
    PySenseUtils.parse_response(resp)
    self._reset(resp.json())
    return True</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.remove_ghost_widgets"><code class="name flex">
<span>def <span class="ident">remove_ghost_widgets</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes ghost widgets from dashboard</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_ghost_widgets(self):
    &#34;&#34;&#34;
    Removes ghost widgets from dashboard  
    &#34;&#34;&#34;
    
    patch_json = {&#34;layout&#34;: self._dashboard_json[&#39;layout&#39;]}
    modified = True
    while modified:
        modified = False
        for l, column in enumerate(patch_json[&#39;layout&#39;][&#39;columns&#39;]):
            for k, cell in enumerate(column[&#39;cells&#39;]):
                for j, sub_cell in enumerate(cell[&#39;subcells&#39;]):
                    for i, element in enumerate(sub_cell[&#39;elements&#39;]):
                        if not self.does_widget_exist(element[&#39;widgetid&#39;]):
                            sub_cell[&#39;elements&#39;].pop(i)
                            modified = True
                    if len(sub_cell[&#39;elements&#39;]) == 0:
                        cell[&#39;subcells&#39;].pop(j)
                if len(cell[&#39;subcells&#39;]) == 0:
                    column[&#39;cells&#39;].pop(k)
            if len(column[&#39;cells&#39;]) == 0:
                patch_json[&#39;layout&#39;][&#39;columns&#39;].pop(l)
    resp = requests.patch(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_id()),
                          headers=self._token, json=patch_json)
    PySenseUtils.parse_response(resp)
    self._reset(resp.json())</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.share_to_user"><code class="name flex">
<span>def <span class="ident">share_to_user</span></span>(<span>self, email, rule, subscribe)</span>
</code></dt>
<dd>
<section class="desc"><p>Share a dashboard to a user
</p>
<p>:param email: The email address of the user<br>
:param rule: The permission of the user on the dashboard (view, edit, etc)<br>
:param subscribe: true or false, whether to subscribe the user to reports
</p>
<p>:return: The updated share</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def share_to_user(self, email, rule, subscribe):
    &#34;&#34;&#34;
    Share a dashboard to a user  

    :param email: The email address of the user  
    :param rule: The permission of the user on the dashboard (view, edit, etc)  
    :param subscribe: true or false, whether to subscribe the user to reports  
      
    :return: The updated share  
    &#34;&#34;&#34;

    user_id = PySenseUtils.get_user_id(self._host, self._token, email)
    shares = self.get_shares()
    shares[&#39;sharesTo&#39;].append({&#39;shareId&#39;: user_id, &#39;type&#39;: &#39;user&#39;, &#39;rule&#39;: rule, &#39;subscribe&#39;: subscribe})
    resp = requests.post(
        &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
        headers=self._token, json=shares)
    PySenseUtils.parse_response(resp)
    return self.get_shares()</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.unshare_to_user"><code class="name flex">
<span>def <span class="ident">unshare_to_user</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<section class="desc"><p>Unshare a dashboard to a user
</p>
<p>:param email: The email address of the user
</p>
<p>:return: The updated share</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unshare_to_user(self, email):
    &#34;&#34;&#34;
    Unshare a dashboard to a user  

    :param email: The email address of the user  
       
    :return: The updated share  
    &#34;&#34;&#34;

    shares = self.get_shares()
    for i, share in enumerate(shares[&#39;sharesTo&#39;]):
        if share[&#39;email&#39;] == email:
            del shares[&#39;sharesTo&#39;][i]
    resp = requests.post(
        &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_id()),
        headers=self._token, json=shares)
    PySenseUtils.parse_response(resp)
    return self.get_shares()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PySense" href="index.html">PySense</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PySense.PySenseDashboard.Dashboard" href="#PySense.PySenseDashboard.Dashboard">Dashboard</a></code></h4>
<ul class="">
<li><code><a title="PySense.PySenseDashboard.Dashboard.add_widget" href="#PySense.PySenseDashboard.Dashboard.add_widget">add_widget</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.delete_widget" href="#PySense.PySenseDashboard.Dashboard.delete_widget">delete_widget</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.does_widget_exist" href="#PySense.PySenseDashboard.Dashboard.does_widget_exist">does_widget_exist</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.export_to_dash" href="#PySense.PySenseDashboard.Dashboard.export_to_dash">export_to_dash</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.export_to_pdf" href="#PySense.PySenseDashboard.Dashboard.export_to_pdf">export_to_pdf</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.export_to_png" href="#PySense.PySenseDashboard.Dashboard.export_to_png">export_to_png</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_folder_id" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_folder_id">get_dashboard_folder_id</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_id" href="#PySense.PySenseDashboard.Dashboard.get_id">get_id</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_name" href="#PySense.PySenseDashboard.Dashboard.get_name">get_name</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_shares" href="#PySense.PySenseDashboard.Dashboard.get_shares">get_shares</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_widget_by_id" href="#PySense.PySenseDashboard.Dashboard.get_widget_by_id">get_widget_by_id</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_widgets" href="#PySense.PySenseDashboard.Dashboard.get_widgets">get_widgets</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.move_to_folder" href="#PySense.PySenseDashboard.Dashboard.move_to_folder">move_to_folder</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.remove_ghost_widgets" href="#PySense.PySenseDashboard.Dashboard.remove_ghost_widgets">remove_ghost_widgets</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.share_to_user" href="#PySense.PySenseDashboard.Dashboard.share_to_user">share_to_user</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.unshare_to_user" href="#PySense.PySenseDashboard.Dashboard.unshare_to_user">unshare_to_user</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>