<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>PySense.PySenseElasticube API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PySense.PySenseElasticube</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import urllib.parse

from PySense import SisenseVersion
from PySense import PySenseDataModel
from PySense import PySenseException
from PySense import PySenseGroup
from PySense import PySenseRule
from PySense import PySenseUser
from PySense import PySenseUtils
from PySense import PySenseFormula


class Elasticube:

    def __init__(self, py_client, cube_json):
        self._cube_json = cube_json
        self._py_client = py_client
        self._server_address = &#39;localhost&#39;
        if py_client.version == SisenseVersion.Version.WINDOWS:
            metadata = self.get_metadata()
            if metadata is None:
                print(&#39;No meta data for cube {}&#39;.format(self.get_title()))
            elif &#39;address&#39; in metadata:
                self._server_address = metadata[&#39;address&#39;]
            elif metadata[&#39;fullname&#39;].endswith(&#39; - Set&#39;):
                self._server_address = &#39;Set&#39;

    def get_oid(self):
        &#34;&#34;&#34;Returns the Elasticube id&#34;&#34;&#34;
        if &#39;oid&#39; in self._cube_json:
            return self._cube_json[&#39;oid&#39;]
        else:
            raise PySenseException(&#39;Cube {} is not currently running so this action cannot be performed&#39;)

    def get_model(self, path=None):
        &#34;&#34;&#34;Returns the data model object for the cube.

        Args:
            - (Optional) path: The file location to save the smodel file to

        Returns:
            A data model or the file path if the file path is set.
        &#34;&#34;&#34;

        query_params = {&#39;datamodelId&#39;: self.get_oid(), &#39;type&#39;: &#39;schema-latest&#39;}
        if path is not None:
            resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/v2/datamodel-exports/schema&#39;,
                                                               query_params=query_params, raw=True)
            with open(path, &#39;wb&#39;) as out_file:
                out_file.write(resp_content)
            return path
        else:
            data_model_json = self._py_client.connector.rest_call(
                &#39;get&#39;, &#39;api/v2/datamodel-exports/schema&#39;, query_params=query_params)
            data_model_json[&#39;oid&#39;] = self.get_oid()
            return PySenseDataModel.DataModel(self._py_client, data_model_json)

    def get_title(self, url_encoded=False):
        &#34;&#34;&#34;Returns the ElastiCube&#39;s title.

        Args:
            - (Optional) url_encoded: True to url encode the name. Use for passing as query parameter.

        Returns:
             The name of the ElastiCube, url encoded if set.
        &#34;&#34;&#34;
        if url_encoded:
            return urllib.parse.quote(self._cube_json[&#39;title&#39;])
        else:
            return self._cube_json[&#39;title&#39;]

    def run_sql(self, query, file_type, *, path=None, server_address=None,
                offset=None, count=None, include_metadata=None, is_masked_response=None):
        &#34;&#34;&#34;Executes ElastiCube sql.

        Args:
            - query: The query to execute
            - file_type: File format to return
            - (Optional) path: The location to save the file
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
            - (Optional) offset: Defines how many items to skip before returning the results.
                For example, to return results from value #101 onward, enter a value of ‘100’.
            - (Optional) count: Limits the result set to a defined number of results. Enter 0 (zero) or leave blank not to limit.
            - (Optional) include_metadata: Whether to include metadata.
            - (Optional) is_masked_response: Whether response should be masked.

        Returns:
             The path of the created file or the content payload if path is None
        &#34;&#34;&#34;

        server_address = server_address if server_address else self._server_address

        query = query.replace(&#34; &#34;, &#34;%20&#34;)

        query_params = {
            &#39;query&#39;: query,
            &#39;format&#39;: file_type,
            &#39;offset&#39;: offset,
            &#39;count&#39;: count,
            &#39;includeMetadata&#39;: include_metadata,
            &#39;isMaskedResponse&#39;: is_masked_response
        }

        if self._py_client.version == SisenseVersion.Version.LINUX:
            resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/datasources/{}/{}/sql&#39;
                                                               .format(server_address, self.get_title(url_encoded=True)),
                                                               query_params=query_params, raw=True)
        else:
            resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/sql&#39;
                                                               .format(self.get_title(url_encoded=True)),
                                                               query_params=query_params, raw=True)
        output = resp_content.decode(&#39;utf-8-sig&#39;).splitlines()
        if path is not None:
            with open(path, &#34;w&#34;) as file:
                for line in output:
                    file.write(line + &#39;\n&#39;)
            return path
        else:
            return resp_content

    def add_security_rule(self, table, column, data_type, *, shares=None, members=None,
                          server_address=None, exclusionary=False, all_members=None):
        &#34;&#34;&#34;Defines data security rules for a column on a specific server and ElastiCube

        Args:
            - table: The table to apply security on
            - column: The column to apply security on
            - data_type: The data type of the column
            - (Optional) shares: The users or groups to assign the security rule to. If none, will be default rule.
            - (Optional) members: An array of values which users should have access to
                If left blank, user will get none.
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
                Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.
            - (Optional) exclusionary: True if exclusionary rule
            - (Optional) all_members: True if all members to be selectable

        Returns:
             The new security rule
        &#34;&#34;&#34;
        server_address = server_address if server_address else self._server_address

        rule_json = [{
            &#34;column&#34;: column,
            &#34;datatype&#34;: data_type,
            &#34;table&#34;: table,
            &#34;elasticube&#34;: self.get_title(),
            &#34;server&#34;: server_address,
            &#34;exclusionary&#34;: exclusionary,
            &#34;allMembers&#34;: all_members
        }]

        shares_json = []
        if shares is None:
            # Default rule
            rule_json[0][&#39;shares&#39;] = [{&#34;type&#34;: &#34;default&#34;}]
        else:
            for party in PySenseUtils.make_iterable(shares):
                if isinstance(party, PySenseUser.User):
                    shares_json.append({&#39;party&#39;: party.get_id(), &#39;type&#39;: &#39;user&#39;})
                elif isinstance(party, PySenseGroup.Group):
                    shares_json.append({&#39;party&#39;: party.get_id(), &#39;type&#39;: &#39;group&#39;})
                else:
                    raise PySenseException.PySenseException(&#39;{} is not a user or a group object&#39;.format(party))
            rule_json[0][&#39;shares&#39;] = shares_json

        member_arr = []
        if members is None:
            rule_json[0][&#39;members&#39;] = []
            rule_json[0][&#39;allMembers&#39;] = False if all_members is None else all_members
        else:
            rule_json[0][&#39;allMembers&#39;] = None
            for member in members:
                member_arr.append(str(member))
            rule_json[0][&#39;members&#39;] = member_arr
        resp_json = self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                                        .format(server_address, self.get_title(url_encoded=True)),
                                                        json_payload=rule_json)

        return PySenseRule.Rule(self._py_client, resp_json[0])

    def get_datasecurity(self, *, server_address=None):
        &#34;&#34;&#34;Return data security rules for the ElastiCube.

        Args:
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
                Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.

        Returns:
            The data security rules for the ElastiCube
        &#34;&#34;&#34;
        server_address = server_address if server_address else self._server_address

        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                                        .format(server_address, self.get_title(url_encoded=True)))
        ret_arr = []
        for rule in resp_json:
            ret_arr.append(PySenseRule.Rule(self._py_client, rule))
        return ret_arr

    def get_datasecurity_by_table_column(self, table, column, *, server_address=None):
        &#34;&#34;&#34;Returns ElastiCube data security rules for a column in a table in the ElastiCube.

        Args:
            - table: The name of the table in the ElastiCube
            - column: The name of the column in the ElastiCube
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
                Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.

        Returns:
            An array of security rules.
        &#34;&#34;&#34;

        server_address = server_address if server_address else self._server_address

        table = urllib.parse.quote(table)
        column = urllib.parse.quote(column)
        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/datasecurity/{}/{}&#39;
                                                        .format(server_address, self.get_title(url_encoded=True),
                                                                table, column))
        ret_arr = []
        for rule in resp_json:
            ret_arr.append(PySenseRule.Rule(self._py_client, rule))
        return ret_arr

    def get_datasecurity_for_user(self, user, *, server_address=None):
        &#34;&#34;&#34;Returns an array of rules for the user on this cube

        Args:
            - user: The user id, username, or user obect
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.

        Returns:
            An array of PySense Rules
        &#34;&#34;&#34;

        server_address = server_address if server_address else self._server_address

        if isinstance(user, PySenseUser.User):
            user_id = user.get_id()
        else:
            user_id = urllib.parse.quote(user)
        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/{}/datasecurity&#39;
                                                        .format(server_address, self.get_title(url_encoded=True),
                                                                user_id))
        ret_arr = []
        for rule in resp_json:
            ret_arr.append(PySenseRule.Rule(self._py_client, rule))
        return ret_arr

    def delete_rule(self, table, column, *, server_address=None):
        &#34;&#34;&#34;Delete data security rule for a column.

        Args:
            - table: The name of the table in the ElastiCube
            - column: The name of the column in the ElastiCube
            - server_address (Optional): The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
                Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.
        &#34;&#34;&#34;
        server_address = server_address if server_address else self._server_address

        query_params = {
            &#39;table&#39;: table,
            &#39;column&#39;: column
        }
        self._py_client.connector.rest_call(&#39;delete&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                            .format(server_address, self.get_title(url_encoded=True)),
                                            query_params=query_params)

    def get_oid(self):
        &#34;&#34;&#34;Returns the Elasticube id&#34;&#34;&#34;
        if &#39;oid&#39; in self._cube_json:
            return self._cube_json[&#39;oid&#39;]
        elif &#39;_id&#39; in self._cube_json:
            return self._cube_json[&#39;_id&#39;]
        else:
            raise PySenseException(&#39;Cube {} is not currently running so this action cannot be performed&#39;)

    def get_saved_formulas(self, *, server_address=None):
        &#34;&#34;&#34;Get elasticube formulas.

        Args:
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.

        Returns:
             An array of formulas
        &#34;&#34;&#34;
        server_address = server_address if server_address else self._server_address
        query_params = {
            &#39;datasource&#39;: self.get_title(url_encoded=True),
            &#39;server&#39;: server_address
        }
        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/metadata/measures&#39;, query_params=query_params)
        ret_arr = []
        for formula in resp_json:
            ret_arr.append(PySenseFormula.Formula(self._py_client, formula))

        return ret_arr

    def delete_formulas(self, formulas):
        &#34;&#34;&#34;Delete given formulas from ElastiCube&#34;&#34;&#34;

        for formula in PySenseUtils.make_iterable(formulas):
            self._py_client.connector.rest_call(&#39;delete&#39;, &#39;api/metadata/{}&#39;.format(formula.get_oid()))

    def get_metadata(self):
        &#34;&#34;&#34;Get ElastiCube metadata&#34;&#34;&#34;
        query_params = {&#34;q&#34;: self.get_title()}
        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/metadata&#39;, query_params=query_params)
        if resp_json is None or len(resp_json) == 0:
            # If we don&#39;t get a response, it means the cube was never built so we return defaults
            return {
                &#34;title&#34;: &#34;&#34;,
                &#34;fullname&#34;: &#34;&#34;,
                &#34;id&#34;: &#34;&#34;,
                &#34;address&#34;: &#34;&#34;,
                &#34;database&#34;: &#34;&#34;
            }
        return resp_json[0]

    def add_formula_to_cube(self, formulas):
        &#34;&#34;&#34;Add formulas to cube&#34;&#34;&#34;
        for formula in PySenseUtils.make_iterable(formulas):
            formula.change_datasource(self)
            elements_to_remove = [&#39;_id&#39;, &#39;created&#39;, &#39;lastUpdated&#39;, &#39;oid&#39;]
            formula_json = formula.get_json()
            for element in elements_to_remove:
                formula_json.pop(element, None)
            self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/metadata&#39;, json_payload=formula_json)

    def start_build(self, build_type, *, server_address=None, orchestrator_task=None):
        &#34;&#34;&#34;Start cube build

        Windows only

        - Args
            - build_type: The build type (schema_changes or full)
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
            - (Optional) orchestrator_task:

        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;start_build&#39;)

        query_params = {
            &#39;type&#39;: build_type,
            &#39;orchestratorTask&#39;: orchestrator_task

        }
        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/startBuild&#39;
                                            .format(server_address, self.get_title(url_encoded=True)),
                                            query_params=query_params)

    def stop_build(self, *, server_address=None):
        &#34;&#34;&#34;Stop cube build

        Windows only

        - Args
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;stop_build&#39;)

        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/stopBuild&#39;
                                            .format(server_address, self.get_title(url_encoded=True)))

    def stop_cube(self, *, server_address=None):
        &#34;&#34;&#34;Stop cube

        Windows only

        - Args
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;stop_cube&#39;)

        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/stop&#39;
                                            .format(server_address, self.get_title(url_encoded=True)))

    def start_cube(self, *, server_address=None):
        &#34;&#34;&#34;Start cube

        Windows only

        - Args
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;start_cube&#39;)

        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/start&#39;
                                            .format(server_address, self.get_title(url_encoded=True)))

    def restart_cube(self, *, server_address=None):
        &#34;&#34;&#34;Start cube

        Windows only

        - Args
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;restart_cube&#39;)

        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/restart&#39;
                                            .format(server_address, self.get_title(url_encoded=True)))

    def add_share(self, shares, *, can_edit=False):
        &#34;&#34;&#34;Share a cube to new groups and users

        By default will give query access. Set can_edit to True for editor access.

        Args:
            shares: One to many PySense Groups and Users
            can_edit: (Optional) True for edit privileges, False or default for query privileges.
        &#34;&#34;&#34;

        shares = PySenseUtils.make_iterable(shares)
        curr_shares_arr = self.get_shares()[&#39;shares&#39;]
        rule = &#39;r&#39; if can_edit is False else &#39;w&#39;
        curr_id_arr = []
        for share in curr_shares_arr:
            party_id = share[&#39;partyId&#39;]
            curr_id_arr.append(party_id)
            del share[&#39;partyId&#39;]
            share[&#39;party&#39;] = party_id

        for share in shares:
            share_id = share.get_id()
            if share_id is None:
                raise PySenseException.PySenseException(&#39;No id found for {}&#39;.format(share))
            elif share_id in curr_id_arr:
                index = curr_id_arr.index(share_id)
                curr_shares_arr[index][&#39;permission&#39;] = rule
            elif isinstance(share, PySenseUser.User):
                curr_shares_arr.append({&#39;party&#39;: share.get_id(), &#39;type&#39;: &#39;user&#39;, &#39;permission&#39;: rule})
            elif isinstance(share, PySenseGroup.Group):
                curr_shares_arr.append({&#39;party&#39;: share.get_id(), &#39;type&#39;: &#39;group&#39;, &#39;rule&#39;: rule})
            else:
                raise PySenseException.PySenseException(&#39;Add Share expected User or group, got {}&#39;.format(type(share)))

        self._py_client.connector.rest_call(&#39;put&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                            .format(self._server_address, self.get_title(url_encoded=True)),
                                            json_payload=curr_shares_arr)

    def remove_shares(self, shares):
        &#34;&#34;&#34;Unshare a cube to groups and users

        Args:
            shares: One to many PySense Groups and Users
        &#34;&#34;&#34;
        shares = PySenseUtils.make_iterable(shares)
        curr_shares_arr = self.get_shares()[&#39;shares&#39;]
        curr_id_arr = []
        for share in curr_shares_arr:
            curr_id_arr.append(share[&#39;partyId&#39;])

        for share in shares:
            share_id = share.get_id()
            if share_id is None:
                raise PySenseException.PySenseException(&#39;No id found for {}&#39;.format(share))
            elif share_id in curr_id_arr:
                index = curr_id_arr.index(share_id)
                del curr_shares_arr[index]
                del curr_id_arr[index]

        self._py_client.connector.rest_call(&#39;put&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                            .format(self._server_address, self.get_title(url_encoded=True)),
                                            json_payload=curr_shares_arr)

    def get_shares(self):
        &#34;&#34;&#34;Returns the shares of the elasticube&#34;&#34;&#34;
        return self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                                   .format(self._server_address, self.get_title(url_encoded=True)))

    def get_address(self):
        &#34;&#34;&#34;Returns the server address from the elasticube metadata&#34;&#34;&#34;
        return self._server_address</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PySense.PySenseElasticube.Elasticube"><code class="flex name class">
<span>class <span class="ident">Elasticube</span></span>
<span>(</span><span>py_client, cube_json)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Elasticube:

    def __init__(self, py_client, cube_json):
        self._cube_json = cube_json
        self._py_client = py_client
        self._server_address = &#39;localhost&#39;
        if py_client.version == SisenseVersion.Version.WINDOWS:
            metadata = self.get_metadata()
            if metadata is None:
                print(&#39;No meta data for cube {}&#39;.format(self.get_title()))
            elif &#39;address&#39; in metadata:
                self._server_address = metadata[&#39;address&#39;]
            elif metadata[&#39;fullname&#39;].endswith(&#39; - Set&#39;):
                self._server_address = &#39;Set&#39;

    def get_oid(self):
        &#34;&#34;&#34;Returns the Elasticube id&#34;&#34;&#34;
        if &#39;oid&#39; in self._cube_json:
            return self._cube_json[&#39;oid&#39;]
        else:
            raise PySenseException(&#39;Cube {} is not currently running so this action cannot be performed&#39;)

    def get_model(self, path=None):
        &#34;&#34;&#34;Returns the data model object for the cube.

        Args:
            - (Optional) path: The file location to save the smodel file to

        Returns:
            A data model or the file path if the file path is set.
        &#34;&#34;&#34;

        query_params = {&#39;datamodelId&#39;: self.get_oid(), &#39;type&#39;: &#39;schema-latest&#39;}
        if path is not None:
            resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/v2/datamodel-exports/schema&#39;,
                                                               query_params=query_params, raw=True)
            with open(path, &#39;wb&#39;) as out_file:
                out_file.write(resp_content)
            return path
        else:
            data_model_json = self._py_client.connector.rest_call(
                &#39;get&#39;, &#39;api/v2/datamodel-exports/schema&#39;, query_params=query_params)
            data_model_json[&#39;oid&#39;] = self.get_oid()
            return PySenseDataModel.DataModel(self._py_client, data_model_json)

    def get_title(self, url_encoded=False):
        &#34;&#34;&#34;Returns the ElastiCube&#39;s title.

        Args:
            - (Optional) url_encoded: True to url encode the name. Use for passing as query parameter.

        Returns:
             The name of the ElastiCube, url encoded if set.
        &#34;&#34;&#34;
        if url_encoded:
            return urllib.parse.quote(self._cube_json[&#39;title&#39;])
        else:
            return self._cube_json[&#39;title&#39;]

    def run_sql(self, query, file_type, *, path=None, server_address=None,
                offset=None, count=None, include_metadata=None, is_masked_response=None):
        &#34;&#34;&#34;Executes ElastiCube sql.

        Args:
            - query: The query to execute
            - file_type: File format to return
            - (Optional) path: The location to save the file
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
            - (Optional) offset: Defines how many items to skip before returning the results.
                For example, to return results from value #101 onward, enter a value of ‘100’.
            - (Optional) count: Limits the result set to a defined number of results. Enter 0 (zero) or leave blank not to limit.
            - (Optional) include_metadata: Whether to include metadata.
            - (Optional) is_masked_response: Whether response should be masked.

        Returns:
             The path of the created file or the content payload if path is None
        &#34;&#34;&#34;

        server_address = server_address if server_address else self._server_address

        query = query.replace(&#34; &#34;, &#34;%20&#34;)

        query_params = {
            &#39;query&#39;: query,
            &#39;format&#39;: file_type,
            &#39;offset&#39;: offset,
            &#39;count&#39;: count,
            &#39;includeMetadata&#39;: include_metadata,
            &#39;isMaskedResponse&#39;: is_masked_response
        }

        if self._py_client.version == SisenseVersion.Version.LINUX:
            resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/datasources/{}/{}/sql&#39;
                                                               .format(server_address, self.get_title(url_encoded=True)),
                                                               query_params=query_params, raw=True)
        else:
            resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/sql&#39;
                                                               .format(self.get_title(url_encoded=True)),
                                                               query_params=query_params, raw=True)
        output = resp_content.decode(&#39;utf-8-sig&#39;).splitlines()
        if path is not None:
            with open(path, &#34;w&#34;) as file:
                for line in output:
                    file.write(line + &#39;\n&#39;)
            return path
        else:
            return resp_content

    def add_security_rule(self, table, column, data_type, *, shares=None, members=None,
                          server_address=None, exclusionary=False, all_members=None):
        &#34;&#34;&#34;Defines data security rules for a column on a specific server and ElastiCube

        Args:
            - table: The table to apply security on
            - column: The column to apply security on
            - data_type: The data type of the column
            - (Optional) shares: The users or groups to assign the security rule to. If none, will be default rule.
            - (Optional) members: An array of values which users should have access to
                If left blank, user will get none.
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
                Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.
            - (Optional) exclusionary: True if exclusionary rule
            - (Optional) all_members: True if all members to be selectable

        Returns:
             The new security rule
        &#34;&#34;&#34;
        server_address = server_address if server_address else self._server_address

        rule_json = [{
            &#34;column&#34;: column,
            &#34;datatype&#34;: data_type,
            &#34;table&#34;: table,
            &#34;elasticube&#34;: self.get_title(),
            &#34;server&#34;: server_address,
            &#34;exclusionary&#34;: exclusionary,
            &#34;allMembers&#34;: all_members
        }]

        shares_json = []
        if shares is None:
            # Default rule
            rule_json[0][&#39;shares&#39;] = [{&#34;type&#34;: &#34;default&#34;}]
        else:
            for party in PySenseUtils.make_iterable(shares):
                if isinstance(party, PySenseUser.User):
                    shares_json.append({&#39;party&#39;: party.get_id(), &#39;type&#39;: &#39;user&#39;})
                elif isinstance(party, PySenseGroup.Group):
                    shares_json.append({&#39;party&#39;: party.get_id(), &#39;type&#39;: &#39;group&#39;})
                else:
                    raise PySenseException.PySenseException(&#39;{} is not a user or a group object&#39;.format(party))
            rule_json[0][&#39;shares&#39;] = shares_json

        member_arr = []
        if members is None:
            rule_json[0][&#39;members&#39;] = []
            rule_json[0][&#39;allMembers&#39;] = False if all_members is None else all_members
        else:
            rule_json[0][&#39;allMembers&#39;] = None
            for member in members:
                member_arr.append(str(member))
            rule_json[0][&#39;members&#39;] = member_arr
        resp_json = self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                                        .format(server_address, self.get_title(url_encoded=True)),
                                                        json_payload=rule_json)

        return PySenseRule.Rule(self._py_client, resp_json[0])

    def get_datasecurity(self, *, server_address=None):
        &#34;&#34;&#34;Return data security rules for the ElastiCube.

        Args:
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
                Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.

        Returns:
            The data security rules for the ElastiCube
        &#34;&#34;&#34;
        server_address = server_address if server_address else self._server_address

        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                                        .format(server_address, self.get_title(url_encoded=True)))
        ret_arr = []
        for rule in resp_json:
            ret_arr.append(PySenseRule.Rule(self._py_client, rule))
        return ret_arr

    def get_datasecurity_by_table_column(self, table, column, *, server_address=None):
        &#34;&#34;&#34;Returns ElastiCube data security rules for a column in a table in the ElastiCube.

        Args:
            - table: The name of the table in the ElastiCube
            - column: The name of the column in the ElastiCube
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
                Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.

        Returns:
            An array of security rules.
        &#34;&#34;&#34;

        server_address = server_address if server_address else self._server_address

        table = urllib.parse.quote(table)
        column = urllib.parse.quote(column)
        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/datasecurity/{}/{}&#39;
                                                        .format(server_address, self.get_title(url_encoded=True),
                                                                table, column))
        ret_arr = []
        for rule in resp_json:
            ret_arr.append(PySenseRule.Rule(self._py_client, rule))
        return ret_arr

    def get_datasecurity_for_user(self, user, *, server_address=None):
        &#34;&#34;&#34;Returns an array of rules for the user on this cube

        Args:
            - user: The user id, username, or user obect
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.

        Returns:
            An array of PySense Rules
        &#34;&#34;&#34;

        server_address = server_address if server_address else self._server_address

        if isinstance(user, PySenseUser.User):
            user_id = user.get_id()
        else:
            user_id = urllib.parse.quote(user)
        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/{}/datasecurity&#39;
                                                        .format(server_address, self.get_title(url_encoded=True),
                                                                user_id))
        ret_arr = []
        for rule in resp_json:
            ret_arr.append(PySenseRule.Rule(self._py_client, rule))
        return ret_arr

    def delete_rule(self, table, column, *, server_address=None):
        &#34;&#34;&#34;Delete data security rule for a column.

        Args:
            - table: The name of the table in the ElastiCube
            - column: The name of the column in the ElastiCube
            - server_address (Optional): The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
                Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.
        &#34;&#34;&#34;
        server_address = server_address if server_address else self._server_address

        query_params = {
            &#39;table&#39;: table,
            &#39;column&#39;: column
        }
        self._py_client.connector.rest_call(&#39;delete&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                            .format(server_address, self.get_title(url_encoded=True)),
                                            query_params=query_params)

    def get_oid(self):
        &#34;&#34;&#34;Returns the Elasticube id&#34;&#34;&#34;
        if &#39;oid&#39; in self._cube_json:
            return self._cube_json[&#39;oid&#39;]
        elif &#39;_id&#39; in self._cube_json:
            return self._cube_json[&#39;_id&#39;]
        else:
            raise PySenseException(&#39;Cube {} is not currently running so this action cannot be performed&#39;)

    def get_saved_formulas(self, *, server_address=None):
        &#34;&#34;&#34;Get elasticube formulas.

        Args:
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.

        Returns:
             An array of formulas
        &#34;&#34;&#34;
        server_address = server_address if server_address else self._server_address
        query_params = {
            &#39;datasource&#39;: self.get_title(url_encoded=True),
            &#39;server&#39;: server_address
        }
        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/metadata/measures&#39;, query_params=query_params)
        ret_arr = []
        for formula in resp_json:
            ret_arr.append(PySenseFormula.Formula(self._py_client, formula))

        return ret_arr

    def delete_formulas(self, formulas):
        &#34;&#34;&#34;Delete given formulas from ElastiCube&#34;&#34;&#34;

        for formula in PySenseUtils.make_iterable(formulas):
            self._py_client.connector.rest_call(&#39;delete&#39;, &#39;api/metadata/{}&#39;.format(formula.get_oid()))

    def get_metadata(self):
        &#34;&#34;&#34;Get ElastiCube metadata&#34;&#34;&#34;
        query_params = {&#34;q&#34;: self.get_title()}
        resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/metadata&#39;, query_params=query_params)
        if resp_json is None or len(resp_json) == 0:
            # If we don&#39;t get a response, it means the cube was never built so we return defaults
            return {
                &#34;title&#34;: &#34;&#34;,
                &#34;fullname&#34;: &#34;&#34;,
                &#34;id&#34;: &#34;&#34;,
                &#34;address&#34;: &#34;&#34;,
                &#34;database&#34;: &#34;&#34;
            }
        return resp_json[0]

    def add_formula_to_cube(self, formulas):
        &#34;&#34;&#34;Add formulas to cube&#34;&#34;&#34;
        for formula in PySenseUtils.make_iterable(formulas):
            formula.change_datasource(self)
            elements_to_remove = [&#39;_id&#39;, &#39;created&#39;, &#39;lastUpdated&#39;, &#39;oid&#39;]
            formula_json = formula.get_json()
            for element in elements_to_remove:
                formula_json.pop(element, None)
            self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/metadata&#39;, json_payload=formula_json)

    def start_build(self, build_type, *, server_address=None, orchestrator_task=None):
        &#34;&#34;&#34;Start cube build

        Windows only

        - Args
            - build_type: The build type (schema_changes or full)
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
            - (Optional) orchestrator_task:

        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;start_build&#39;)

        query_params = {
            &#39;type&#39;: build_type,
            &#39;orchestratorTask&#39;: orchestrator_task

        }
        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/startBuild&#39;
                                            .format(server_address, self.get_title(url_encoded=True)),
                                            query_params=query_params)

    def stop_build(self, *, server_address=None):
        &#34;&#34;&#34;Stop cube build

        Windows only

        - Args
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;stop_build&#39;)

        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/stopBuild&#39;
                                            .format(server_address, self.get_title(url_encoded=True)))

    def stop_cube(self, *, server_address=None):
        &#34;&#34;&#34;Stop cube

        Windows only

        - Args
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;stop_cube&#39;)

        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/stop&#39;
                                            .format(server_address, self.get_title(url_encoded=True)))

    def start_cube(self, *, server_address=None):
        &#34;&#34;&#34;Start cube

        Windows only

        - Args
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;start_cube&#39;)

        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/start&#39;
                                            .format(server_address, self.get_title(url_encoded=True)))

    def restart_cube(self, *, server_address=None):
        &#34;&#34;&#34;Start cube

        Windows only

        - Args
            - (Optional) server_address: The server address of the ElastiCube.
                Set this to your server ip if this method fails without it set.
        &#34;&#34;&#34;
        PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;restart_cube&#39;)

        server_address = server_address if server_address else self._server_address
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/restart&#39;
                                            .format(server_address, self.get_title(url_encoded=True)))

    def add_share(self, shares, *, can_edit=False):
        &#34;&#34;&#34;Share a cube to new groups and users

        By default will give query access. Set can_edit to True for editor access.

        Args:
            shares: One to many PySense Groups and Users
            can_edit: (Optional) True for edit privileges, False or default for query privileges.
        &#34;&#34;&#34;

        shares = PySenseUtils.make_iterable(shares)
        curr_shares_arr = self.get_shares()[&#39;shares&#39;]
        rule = &#39;r&#39; if can_edit is False else &#39;w&#39;
        curr_id_arr = []
        for share in curr_shares_arr:
            party_id = share[&#39;partyId&#39;]
            curr_id_arr.append(party_id)
            del share[&#39;partyId&#39;]
            share[&#39;party&#39;] = party_id

        for share in shares:
            share_id = share.get_id()
            if share_id is None:
                raise PySenseException.PySenseException(&#39;No id found for {}&#39;.format(share))
            elif share_id in curr_id_arr:
                index = curr_id_arr.index(share_id)
                curr_shares_arr[index][&#39;permission&#39;] = rule
            elif isinstance(share, PySenseUser.User):
                curr_shares_arr.append({&#39;party&#39;: share.get_id(), &#39;type&#39;: &#39;user&#39;, &#39;permission&#39;: rule})
            elif isinstance(share, PySenseGroup.Group):
                curr_shares_arr.append({&#39;party&#39;: share.get_id(), &#39;type&#39;: &#39;group&#39;, &#39;rule&#39;: rule})
            else:
                raise PySenseException.PySenseException(&#39;Add Share expected User or group, got {}&#39;.format(type(share)))

        self._py_client.connector.rest_call(&#39;put&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                            .format(self._server_address, self.get_title(url_encoded=True)),
                                            json_payload=curr_shares_arr)

    def remove_shares(self, shares):
        &#34;&#34;&#34;Unshare a cube to groups and users

        Args:
            shares: One to many PySense Groups and Users
        &#34;&#34;&#34;
        shares = PySenseUtils.make_iterable(shares)
        curr_shares_arr = self.get_shares()[&#39;shares&#39;]
        curr_id_arr = []
        for share in curr_shares_arr:
            curr_id_arr.append(share[&#39;partyId&#39;])

        for share in shares:
            share_id = share.get_id()
            if share_id is None:
                raise PySenseException.PySenseException(&#39;No id found for {}&#39;.format(share))
            elif share_id in curr_id_arr:
                index = curr_id_arr.index(share_id)
                del curr_shares_arr[index]
                del curr_id_arr[index]

        self._py_client.connector.rest_call(&#39;put&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                            .format(self._server_address, self.get_title(url_encoded=True)),
                                            json_payload=curr_shares_arr)

    def get_shares(self):
        &#34;&#34;&#34;Returns the shares of the elasticube&#34;&#34;&#34;
        return self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                                   .format(self._server_address, self.get_title(url_encoded=True)))

    def get_address(self):
        &#34;&#34;&#34;Returns the server address from the elasticube metadata&#34;&#34;&#34;
        return self._server_address</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PySense.PySenseElasticube.Elasticube.add_formula_to_cube"><code class="name flex">
<span>def <span class="ident">add_formula_to_cube</span></span>(<span>self, formulas)</span>
</code></dt>
<dd>
<div class="desc"><p>Add formulas to cube</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_formula_to_cube(self, formulas):
    &#34;&#34;&#34;Add formulas to cube&#34;&#34;&#34;
    for formula in PySenseUtils.make_iterable(formulas):
        formula.change_datasource(self)
        elements_to_remove = [&#39;_id&#39;, &#39;created&#39;, &#39;lastUpdated&#39;, &#39;oid&#39;]
        formula_json = formula.get_json()
        for element in elements_to_remove:
            formula_json.pop(element, None)
        self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/metadata&#39;, json_payload=formula_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.add_security_rule"><code class="name flex">
<span>def <span class="ident">add_security_rule</span></span>(<span>self, table, column, data_type, *, shares=None, members=None, server_address=None, exclusionary=False, all_members=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines data security rules for a column on a specific server and ElastiCube</p>
<h2 id="args">Args</h2>
<ul>
<li>table: The table to apply security on</li>
<li>column: The column to apply security on</li>
<li>data_type: The data type of the column</li>
<li>(Optional) shares: The users or groups to assign the security rule to. If none, will be default rule.</li>
<li>(Optional) members: An array of values which users should have access to
If left blank, user will get none.</li>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.
Use 'Set' for Elasticube Set. Required for elasticube sets.</li>
<li>(Optional) exclusionary: True if exclusionary rule</li>
<li>(Optional) all_members: True if all members to be selectable</li>
</ul>
<h2 id="returns">Returns</h2>
<p>The new security rule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_security_rule(self, table, column, data_type, *, shares=None, members=None,
                      server_address=None, exclusionary=False, all_members=None):
    &#34;&#34;&#34;Defines data security rules for a column on a specific server and ElastiCube

    Args:
        - table: The table to apply security on
        - column: The column to apply security on
        - data_type: The data type of the column
        - (Optional) shares: The users or groups to assign the security rule to. If none, will be default rule.
        - (Optional) members: An array of values which users should have access to
            If left blank, user will get none.
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
            Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.
        - (Optional) exclusionary: True if exclusionary rule
        - (Optional) all_members: True if all members to be selectable

    Returns:
         The new security rule
    &#34;&#34;&#34;
    server_address = server_address if server_address else self._server_address

    rule_json = [{
        &#34;column&#34;: column,
        &#34;datatype&#34;: data_type,
        &#34;table&#34;: table,
        &#34;elasticube&#34;: self.get_title(),
        &#34;server&#34;: server_address,
        &#34;exclusionary&#34;: exclusionary,
        &#34;allMembers&#34;: all_members
    }]

    shares_json = []
    if shares is None:
        # Default rule
        rule_json[0][&#39;shares&#39;] = [{&#34;type&#34;: &#34;default&#34;}]
    else:
        for party in PySenseUtils.make_iterable(shares):
            if isinstance(party, PySenseUser.User):
                shares_json.append({&#39;party&#39;: party.get_id(), &#39;type&#39;: &#39;user&#39;})
            elif isinstance(party, PySenseGroup.Group):
                shares_json.append({&#39;party&#39;: party.get_id(), &#39;type&#39;: &#39;group&#39;})
            else:
                raise PySenseException.PySenseException(&#39;{} is not a user or a group object&#39;.format(party))
        rule_json[0][&#39;shares&#39;] = shares_json

    member_arr = []
    if members is None:
        rule_json[0][&#39;members&#39;] = []
        rule_json[0][&#39;allMembers&#39;] = False if all_members is None else all_members
    else:
        rule_json[0][&#39;allMembers&#39;] = None
        for member in members:
            member_arr.append(str(member))
        rule_json[0][&#39;members&#39;] = member_arr
    resp_json = self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                                    .format(server_address, self.get_title(url_encoded=True)),
                                                    json_payload=rule_json)

    return PySenseRule.Rule(self._py_client, resp_json[0])</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.add_share"><code class="name flex">
<span>def <span class="ident">add_share</span></span>(<span>self, shares, *, can_edit=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Share a cube to new groups and users</p>
<p>By default will give query access. Set can_edit to True for editor access.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shares</code></strong></dt>
<dd>One to many PySense Groups and Users</dd>
<dt><strong><code>can_edit</code></strong></dt>
<dd>(Optional) True for edit privileges, False or default for query privileges.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_share(self, shares, *, can_edit=False):
    &#34;&#34;&#34;Share a cube to new groups and users

    By default will give query access. Set can_edit to True for editor access.

    Args:
        shares: One to many PySense Groups and Users
        can_edit: (Optional) True for edit privileges, False or default for query privileges.
    &#34;&#34;&#34;

    shares = PySenseUtils.make_iterable(shares)
    curr_shares_arr = self.get_shares()[&#39;shares&#39;]
    rule = &#39;r&#39; if can_edit is False else &#39;w&#39;
    curr_id_arr = []
    for share in curr_shares_arr:
        party_id = share[&#39;partyId&#39;]
        curr_id_arr.append(party_id)
        del share[&#39;partyId&#39;]
        share[&#39;party&#39;] = party_id

    for share in shares:
        share_id = share.get_id()
        if share_id is None:
            raise PySenseException.PySenseException(&#39;No id found for {}&#39;.format(share))
        elif share_id in curr_id_arr:
            index = curr_id_arr.index(share_id)
            curr_shares_arr[index][&#39;permission&#39;] = rule
        elif isinstance(share, PySenseUser.User):
            curr_shares_arr.append({&#39;party&#39;: share.get_id(), &#39;type&#39;: &#39;user&#39;, &#39;permission&#39;: rule})
        elif isinstance(share, PySenseGroup.Group):
            curr_shares_arr.append({&#39;party&#39;: share.get_id(), &#39;type&#39;: &#39;group&#39;, &#39;rule&#39;: rule})
        else:
            raise PySenseException.PySenseException(&#39;Add Share expected User or group, got {}&#39;.format(type(share)))

    self._py_client.connector.rest_call(&#39;put&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                        .format(self._server_address, self.get_title(url_encoded=True)),
                                        json_payload=curr_shares_arr)</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.delete_formulas"><code class="name flex">
<span>def <span class="ident">delete_formulas</span></span>(<span>self, formulas)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete given formulas from ElastiCube</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_formulas(self, formulas):
    &#34;&#34;&#34;Delete given formulas from ElastiCube&#34;&#34;&#34;

    for formula in PySenseUtils.make_iterable(formulas):
        self._py_client.connector.rest_call(&#39;delete&#39;, &#39;api/metadata/{}&#39;.format(formula.get_oid()))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.delete_rule"><code class="name flex">
<span>def <span class="ident">delete_rule</span></span>(<span>self, table, column, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete data security rule for a column.</p>
<h2 id="args">Args</h2>
<ul>
<li>table: The name of the table in the ElastiCube</li>
<li>column: The name of the column in the ElastiCube</li>
<li>server_address (Optional): The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.
Use 'Set' for Elasticube Set. Required for elasticube sets.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_rule(self, table, column, *, server_address=None):
    &#34;&#34;&#34;Delete data security rule for a column.

    Args:
        - table: The name of the table in the ElastiCube
        - column: The name of the column in the ElastiCube
        - server_address (Optional): The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
            Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.
    &#34;&#34;&#34;
    server_address = server_address if server_address else self._server_address

    query_params = {
        &#39;table&#39;: table,
        &#39;column&#39;: column
    }
    self._py_client.connector.rest_call(&#39;delete&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                        .format(server_address, self.get_title(url_encoded=True)),
                                        query_params=query_params)</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_address"><code class="name flex">
<span>def <span class="ident">get_address</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the server address from the elasticube metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_address(self):
    &#34;&#34;&#34;Returns the server address from the elasticube metadata&#34;&#34;&#34;
    return self._server_address</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_datasecurity"><code class="name flex">
<span>def <span class="ident">get_datasecurity</span></span>(<span>self, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return data security rules for the ElastiCube.</p>
<h2 id="args">Args</h2>
<ul>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.
Use 'Set' for Elasticube Set. Required for elasticube sets.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>The data security rules for the ElastiCube</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datasecurity(self, *, server_address=None):
    &#34;&#34;&#34;Return data security rules for the ElastiCube.

    Args:
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
            Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.

    Returns:
        The data security rules for the ElastiCube
    &#34;&#34;&#34;
    server_address = server_address if server_address else self._server_address

    resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/datasecurity&#39;
                                                    .format(server_address, self.get_title(url_encoded=True)))
    ret_arr = []
    for rule in resp_json:
        ret_arr.append(PySenseRule.Rule(self._py_client, rule))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_datasecurity_by_table_column"><code class="name flex">
<span>def <span class="ident">get_datasecurity_by_table_column</span></span>(<span>self, table, column, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns ElastiCube data security rules for a column in a table in the ElastiCube.</p>
<h2 id="args">Args</h2>
<ul>
<li>table: The name of the table in the ElastiCube</li>
<li>column: The name of the column in the ElastiCube</li>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.
Use 'Set' for Elasticube Set. Required for elasticube sets.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>An array of security rules.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datasecurity_by_table_column(self, table, column, *, server_address=None):
    &#34;&#34;&#34;Returns ElastiCube data security rules for a column in a table in the ElastiCube.

    Args:
        - table: The name of the table in the ElastiCube
        - column: The name of the column in the ElastiCube
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
            Use &#39;Set&#39; for Elasticube Set. Required for elasticube sets.

    Returns:
        An array of security rules.
    &#34;&#34;&#34;

    server_address = server_address if server_address else self._server_address

    table = urllib.parse.quote(table)
    column = urllib.parse.quote(column)
    resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/datasecurity/{}/{}&#39;
                                                    .format(server_address, self.get_title(url_encoded=True),
                                                            table, column))
    ret_arr = []
    for rule in resp_json:
        ret_arr.append(PySenseRule.Rule(self._py_client, rule))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_datasecurity_for_user"><code class="name flex">
<span>def <span class="ident">get_datasecurity_for_user</span></span>(<span>self, user, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an array of rules for the user on this cube</p>
<h2 id="args">Args</h2>
<ul>
<li>user: The user id, username, or user obect</li>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>An array of PySense Rules</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datasecurity_for_user(self, user, *, server_address=None):
    &#34;&#34;&#34;Returns an array of rules for the user on this cube

    Args:
        - user: The user id, username, or user obect
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.

    Returns:
        An array of PySense Rules
    &#34;&#34;&#34;

    server_address = server_address if server_address else self._server_address

    if isinstance(user, PySenseUser.User):
        user_id = user.get_id()
    else:
        user_id = urllib.parse.quote(user)
    resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/{}/datasecurity&#39;
                                                    .format(server_address, self.get_title(url_encoded=True),
                                                            user_id))
    ret_arr = []
    for rule in resp_json:
        ret_arr.append(PySenseRule.Rule(self._py_client, rule))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get ElastiCube metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata(self):
    &#34;&#34;&#34;Get ElastiCube metadata&#34;&#34;&#34;
    query_params = {&#34;q&#34;: self.get_title()}
    resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/metadata&#39;, query_params=query_params)
    if resp_json is None or len(resp_json) == 0:
        # If we don&#39;t get a response, it means the cube was never built so we return defaults
        return {
            &#34;title&#34;: &#34;&#34;,
            &#34;fullname&#34;: &#34;&#34;,
            &#34;id&#34;: &#34;&#34;,
            &#34;address&#34;: &#34;&#34;,
            &#34;database&#34;: &#34;&#34;
        }
    return resp_json[0]</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_model"><code class="name flex">
<span>def <span class="ident">get_model</span></span>(<span>self, path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the data model object for the cube.</p>
<h2 id="args">Args</h2>
<ul>
<li>(Optional) path: The file location to save the smodel file to</li>
</ul>
<h2 id="returns">Returns</h2>
<p>A data model or the file path if the file path is set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model(self, path=None):
    &#34;&#34;&#34;Returns the data model object for the cube.

    Args:
        - (Optional) path: The file location to save the smodel file to

    Returns:
        A data model or the file path if the file path is set.
    &#34;&#34;&#34;

    query_params = {&#39;datamodelId&#39;: self.get_oid(), &#39;type&#39;: &#39;schema-latest&#39;}
    if path is not None:
        resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/v2/datamodel-exports/schema&#39;,
                                                           query_params=query_params, raw=True)
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp_content)
        return path
    else:
        data_model_json = self._py_client.connector.rest_call(
            &#39;get&#39;, &#39;api/v2/datamodel-exports/schema&#39;, query_params=query_params)
        data_model_json[&#39;oid&#39;] = self.get_oid()
        return PySenseDataModel.DataModel(self._py_client, data_model_json)</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_oid"><code class="name flex">
<span>def <span class="ident">get_oid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Elasticube id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_oid(self):
    &#34;&#34;&#34;Returns the Elasticube id&#34;&#34;&#34;
    if &#39;oid&#39; in self._cube_json:
        return self._cube_json[&#39;oid&#39;]
    elif &#39;_id&#39; in self._cube_json:
        return self._cube_json[&#39;_id&#39;]
    else:
        raise PySenseException(&#39;Cube {} is not currently running so this action cannot be performed&#39;)</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_saved_formulas"><code class="name flex">
<span>def <span class="ident">get_saved_formulas</span></span>(<span>self, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get elasticube formulas.</p>
<h2 id="args">Args</h2>
<ul>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>An array of formulas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_saved_formulas(self, *, server_address=None):
    &#34;&#34;&#34;Get elasticube formulas.

    Args:
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.

    Returns:
         An array of formulas
    &#34;&#34;&#34;
    server_address = server_address if server_address else self._server_address
    query_params = {
        &#39;datasource&#39;: self.get_title(url_encoded=True),
        &#39;server&#39;: server_address
    }
    resp_json = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/metadata/measures&#39;, query_params=query_params)
    ret_arr = []
    for formula in resp_json:
        ret_arr.append(PySenseFormula.Formula(self._py_client, formula))

    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_shares"><code class="name flex">
<span>def <span class="ident">get_shares</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the shares of the elasticube</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shares(self):
    &#34;&#34;&#34;Returns the shares of the elasticube&#34;&#34;&#34;
    return self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                               .format(self._server_address, self.get_title(url_encoded=True)))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.get_title"><code class="name flex">
<span>def <span class="ident">get_title</span></span>(<span>self, url_encoded=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ElastiCube's title.</p>
<h2 id="args">Args</h2>
<ul>
<li>(Optional) url_encoded: True to url encode the name. Use for passing as query parameter.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>The name of the ElastiCube, url encoded if set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_title(self, url_encoded=False):
    &#34;&#34;&#34;Returns the ElastiCube&#39;s title.

    Args:
        - (Optional) url_encoded: True to url encode the name. Use for passing as query parameter.

    Returns:
         The name of the ElastiCube, url encoded if set.
    &#34;&#34;&#34;
    if url_encoded:
        return urllib.parse.quote(self._cube_json[&#39;title&#39;])
    else:
        return self._cube_json[&#39;title&#39;]</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.remove_shares"><code class="name flex">
<span>def <span class="ident">remove_shares</span></span>(<span>self, shares)</span>
</code></dt>
<dd>
<div class="desc"><p>Unshare a cube to groups and users</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shares</code></strong></dt>
<dd>One to many PySense Groups and Users</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_shares(self, shares):
    &#34;&#34;&#34;Unshare a cube to groups and users

    Args:
        shares: One to many PySense Groups and Users
    &#34;&#34;&#34;
    shares = PySenseUtils.make_iterable(shares)
    curr_shares_arr = self.get_shares()[&#39;shares&#39;]
    curr_id_arr = []
    for share in curr_shares_arr:
        curr_id_arr.append(share[&#39;partyId&#39;])

    for share in shares:
        share_id = share.get_id()
        if share_id is None:
            raise PySenseException.PySenseException(&#39;No id found for {}&#39;.format(share))
        elif share_id in curr_id_arr:
            index = curr_id_arr.index(share_id)
            del curr_shares_arr[index]
            del curr_id_arr[index]

    self._py_client.connector.rest_call(&#39;put&#39;, &#39;api/elasticubes/{}/{}/permissions&#39;
                                        .format(self._server_address, self.get_title(url_encoded=True)),
                                        json_payload=curr_shares_arr)</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.restart_cube"><code class="name flex">
<span>def <span class="ident">restart_cube</span></span>(<span>self, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Start cube</p>
<p>Windows only</p>
<ul>
<li>Args<ul>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restart_cube(self, *, server_address=None):
    &#34;&#34;&#34;Start cube

    Windows only

    - Args
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
    &#34;&#34;&#34;
    PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;restart_cube&#39;)

    server_address = server_address if server_address else self._server_address
    self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/restart&#39;
                                        .format(server_address, self.get_title(url_encoded=True)))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.run_sql"><code class="name flex">
<span>def <span class="ident">run_sql</span></span>(<span>self, query, file_type, *, path=None, server_address=None, offset=None, count=None, include_metadata=None, is_masked_response=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes ElastiCube sql.</p>
<h2 id="args">Args</h2>
<ul>
<li>query: The query to execute</li>
<li>file_type: File format to return</li>
<li>(Optional) path: The location to save the file</li>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.</li>
<li>(Optional) offset: Defines how many items to skip before returning the results.
For example, to return results from value #101 onward, enter a value of ‘100’.</li>
<li>(Optional) count: Limits the result set to a defined number of results. Enter 0 (zero) or leave blank not to limit.</li>
<li>(Optional) include_metadata: Whether to include metadata.</li>
<li>(Optional) is_masked_response: Whether response should be masked.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>The path of the created file or the content payload if path is None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_sql(self, query, file_type, *, path=None, server_address=None,
            offset=None, count=None, include_metadata=None, is_masked_response=None):
    &#34;&#34;&#34;Executes ElastiCube sql.

    Args:
        - query: The query to execute
        - file_type: File format to return
        - (Optional) path: The location to save the file
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
        - (Optional) offset: Defines how many items to skip before returning the results.
            For example, to return results from value #101 onward, enter a value of ‘100’.
        - (Optional) count: Limits the result set to a defined number of results. Enter 0 (zero) or leave blank not to limit.
        - (Optional) include_metadata: Whether to include metadata.
        - (Optional) is_masked_response: Whether response should be masked.

    Returns:
         The path of the created file or the content payload if path is None
    &#34;&#34;&#34;

    server_address = server_address if server_address else self._server_address

    query = query.replace(&#34; &#34;, &#34;%20&#34;)

    query_params = {
        &#39;query&#39;: query,
        &#39;format&#39;: file_type,
        &#39;offset&#39;: offset,
        &#39;count&#39;: count,
        &#39;includeMetadata&#39;: include_metadata,
        &#39;isMaskedResponse&#39;: is_masked_response
    }

    if self._py_client.version == SisenseVersion.Version.LINUX:
        resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/datasources/{}/{}/sql&#39;
                                                           .format(server_address, self.get_title(url_encoded=True)),
                                                           query_params=query_params, raw=True)
    else:
        resp_content = self._py_client.connector.rest_call(&#39;get&#39;, &#39;api/elasticubes/{}/sql&#39;
                                                           .format(self.get_title(url_encoded=True)),
                                                           query_params=query_params, raw=True)
    output = resp_content.decode(&#39;utf-8-sig&#39;).splitlines()
    if path is not None:
        with open(path, &#34;w&#34;) as file:
            for line in output:
                file.write(line + &#39;\n&#39;)
        return path
    else:
        return resp_content</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.start_build"><code class="name flex">
<span>def <span class="ident">start_build</span></span>(<span>self, build_type, *, server_address=None, orchestrator_task=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Start cube build</p>
<p>Windows only</p>
<ul>
<li>Args<ul>
<li>build_type: The build type (schema_changes or full)</li>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.</li>
<li>(Optional) orchestrator_task:</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_build(self, build_type, *, server_address=None, orchestrator_task=None):
    &#34;&#34;&#34;Start cube build

    Windows only

    - Args
        - build_type: The build type (schema_changes or full)
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
        - (Optional) orchestrator_task:

    &#34;&#34;&#34;
    PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;start_build&#39;)

    query_params = {
        &#39;type&#39;: build_type,
        &#39;orchestratorTask&#39;: orchestrator_task

    }
    server_address = server_address if server_address else self._server_address
    self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/startBuild&#39;
                                        .format(server_address, self.get_title(url_encoded=True)),
                                        query_params=query_params)</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.start_cube"><code class="name flex">
<span>def <span class="ident">start_cube</span></span>(<span>self, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Start cube</p>
<p>Windows only</p>
<ul>
<li>Args<ul>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_cube(self, *, server_address=None):
    &#34;&#34;&#34;Start cube

    Windows only

    - Args
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
    &#34;&#34;&#34;
    PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;start_cube&#39;)

    server_address = server_address if server_address else self._server_address
    self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/start&#39;
                                        .format(server_address, self.get_title(url_encoded=True)))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.stop_build"><code class="name flex">
<span>def <span class="ident">stop_build</span></span>(<span>self, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop cube build</p>
<p>Windows only</p>
<ul>
<li>Args<ul>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_build(self, *, server_address=None):
    &#34;&#34;&#34;Stop cube build

    Windows only

    - Args
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
    &#34;&#34;&#34;
    PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;stop_build&#39;)

    server_address = server_address if server_address else self._server_address
    self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/stopBuild&#39;
                                        .format(server_address, self.get_title(url_encoded=True)))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseElasticube.Elasticube.stop_cube"><code class="name flex">
<span>def <span class="ident">stop_cube</span></span>(<span>self, *, server_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop cube</p>
<p>Windows only</p>
<ul>
<li>Args<ul>
<li>(Optional) server_address: The server address of the ElastiCube.
Set this to your server ip if this method fails without it set.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_cube(self, *, server_address=None):
    &#34;&#34;&#34;Stop cube

    Windows only

    - Args
        - (Optional) server_address: The server address of the ElastiCube.
            Set this to your server ip if this method fails without it set.
    &#34;&#34;&#34;
    PySenseUtils.validate_version(self._py_client, SisenseVersion.Version.WINDOWS, &#39;stop_cube&#39;)

    server_address = server_address if server_address else self._server_address
    self._py_client.connector.rest_call(&#39;post&#39;, &#39;api/elasticubes/{}/{}/stop&#39;
                                        .format(server_address, self.get_title(url_encoded=True)))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PySense" href="index.html">PySense</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PySense.PySenseElasticube.Elasticube" href="#PySense.PySenseElasticube.Elasticube">Elasticube</a></code></h4>
<ul class="">
<li><code><a title="PySense.PySenseElasticube.Elasticube.add_formula_to_cube" href="#PySense.PySenseElasticube.Elasticube.add_formula_to_cube">add_formula_to_cube</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.add_security_rule" href="#PySense.PySenseElasticube.Elasticube.add_security_rule">add_security_rule</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.add_share" href="#PySense.PySenseElasticube.Elasticube.add_share">add_share</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.delete_formulas" href="#PySense.PySenseElasticube.Elasticube.delete_formulas">delete_formulas</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.delete_rule" href="#PySense.PySenseElasticube.Elasticube.delete_rule">delete_rule</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_address" href="#PySense.PySenseElasticube.Elasticube.get_address">get_address</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_datasecurity" href="#PySense.PySenseElasticube.Elasticube.get_datasecurity">get_datasecurity</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_datasecurity_by_table_column" href="#PySense.PySenseElasticube.Elasticube.get_datasecurity_by_table_column">get_datasecurity_by_table_column</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_datasecurity_for_user" href="#PySense.PySenseElasticube.Elasticube.get_datasecurity_for_user">get_datasecurity_for_user</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_metadata" href="#PySense.PySenseElasticube.Elasticube.get_metadata">get_metadata</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_model" href="#PySense.PySenseElasticube.Elasticube.get_model">get_model</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_oid" href="#PySense.PySenseElasticube.Elasticube.get_oid">get_oid</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_saved_formulas" href="#PySense.PySenseElasticube.Elasticube.get_saved_formulas">get_saved_formulas</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_shares" href="#PySense.PySenseElasticube.Elasticube.get_shares">get_shares</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.get_title" href="#PySense.PySenseElasticube.Elasticube.get_title">get_title</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.remove_shares" href="#PySense.PySenseElasticube.Elasticube.remove_shares">remove_shares</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.restart_cube" href="#PySense.PySenseElasticube.Elasticube.restart_cube">restart_cube</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.run_sql" href="#PySense.PySenseElasticube.Elasticube.run_sql">run_sql</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.start_build" href="#PySense.PySenseElasticube.Elasticube.start_build">start_build</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.start_cube" href="#PySense.PySenseElasticube.Elasticube.start_cube">start_cube</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.stop_build" href="#PySense.PySenseElasticube.Elasticube.stop_build">stop_build</a></code></li>
<li><code><a title="PySense.PySenseElasticube.Elasticube.stop_cube" href="#PySense.PySenseElasticube.Elasticube.stop_cube">stop_cube</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>